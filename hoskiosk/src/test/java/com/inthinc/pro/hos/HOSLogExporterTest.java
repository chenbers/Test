package com.inthinc.pro.hos;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.fail;

import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Arrays;
import java.util.Date;
import java.util.SimpleTimeZone;
import java.util.TimeZone;

import org.junit.Test;

import com.inthinc.hos.model.HOSOrigin;
import com.inthinc.hos.model.HOSStatus;
import com.inthinc.hos.model.RuleSetType;
import com.inthinc.pro.model.hos.HOSRecord;


public class HOSLogExporterTest {

    SimpleDateFormat dateFormat = new SimpleDateFormat("MMM dd yyyy hh:mm:ss:SSSa");

    HOSRecord testdata[] = {
            new HOSRecord(0, 0, RuleSetType.US_OIL, 0, "", true, 14l, parseDBDate("Sep 23 2010 10:29:20:623PM"), null, TimeZone.getTimeZone("US/Mountain"), HOSStatus.OFF_DUTY, HOSOrigin.PORTAL, "Salt Lake City, UT", 0f, 0f, 0l, "","",false, false, "", false),
            new HOSRecord(0, 0, RuleSetType.US_OIL, 0, "", true, 14l, parseDBDate("Aug 18 2010  8:15:06:000PM"), null, TimeZone.getTimeZone("US/Mountain"), HOSStatus.SLEEPER, HOSOrigin.PORTAL, "test city, UT", 0f, 0f, 0l, "","",false, false, "", false),
            
    };
    
    private static String EXPECTED_EXPORTED_FILE = "driver_20138.log";
    
    @Test
    public void testWriteHOSDriverStateHistoryToStream(){
        
        OutputStream os = new ByteArrayOutputStream();
        
        HOSLogExporter exporter = new HOSLogExporter(null);
        
        Arrays.asList(testdata);
        
        try {
            exporter.writeHOSDriverStateHistoryToStream(os, Arrays.asList(testdata));
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        
        byte[] genBytes = os.toString().getBytes();
        DataInputStream dInput = new DataInputStream(Thread.currentThread().getContextClassLoader().getResourceAsStream(EXPECTED_EXPORTED_FILE));
        try {
            byte[] expectedBytes = new byte[dInput.available()];
            dInput.readFully(expectedBytes);
            System.out.println("expected len " + expectedBytes.length);
            System.out.println("gen len " + genBytes.length);
            System.out.println("expected");
            for (int i = 0; i < expectedBytes.length; i++) {
                if ((i+1) % 10 == 0 )
                    System.out.println(expectedBytes[i]);
                else System.out.print(expectedBytes[i] + " ");
            }
            System.out.println();
            System.out.println("gen");
            for (int i = 0; i < genBytes.length; i++) {
                if ((i+1) % 10 == 0 )
                    System.out.println(genBytes[i]);
                else System.out.print(genBytes[i] + " ");
            }

            
            
//            assertEquals("generated size does not match expected", expectedBytes.length, genBytes.length);
            
            for (int i = 0; i < expectedBytes.length; i++) {
                if (expectedBytes[i] != genBytes[i]) {
                    System.out.println(i + " " + expectedBytes[i] + " " + genBytes[i]);
                    fail("generated bytes do not match expected byte #" + i);
                }
            }
                
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        
    }
    
    private Date parseDBDate(String dateStr) {
        dateFormat.setTimeZone(new SimpleTimeZone(0, "UTC"));
        try {
            Date date = dateFormat.parse(dateStr);
            System.out.println(" " + date.getTime());
            return date;
        } catch (ParseException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
            return null;
        }
    }

}
