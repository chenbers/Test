 /**
* @class Pareto2DChart
* @author FusionCharts Technologies LLP, www.fusioncharts.com
* @version 3.2
*
* Copyright (C) FusionCharts Technologies LLP, 2010
*
* Pareto2DChart chart extends the DualYAxis2DChart class to render a
* Pareto Chart.
*/
//Import Chart class
import com.fusioncharts.core.Chart;
//Parent DualYAxis2DChart Class
import com.fusioncharts.core.DualYAxis2DChart;
//Error class
import com.fusioncharts.helper.FCError;
//Import Logger Class
import com.fusioncharts.helper.Logger;
//Style Object
import com.fusioncharts.core.StyleObject;
//Delegate
import mx.utils.Delegate;
//Columns
import com.fusioncharts.core.chartobjects.Column2D;
import com.fusioncharts.core.chartobjects.RoundColumn2D;
import com.fusioncharts.helper.LabelMetrics;
import com.fusioncharts.helper.LabelRenderer;
//Extensions
import com.fusioncharts.extensions.ColorExt;
import com.fusioncharts.extensions.StringExt;
import com.fusioncharts.extensions.MathExt;
import com.fusioncharts.extensions.DrawingExt;
class com.fusioncharts.core.charts.Pareto2DChart extends DualYAxis2DChart 
{
	//Version number (if different from super Chart class)
	//private var _version:String = "3.0.0";
	//Instance variables
	//List of chart objects
	private var _arrObjects : Array;
	private var xmlData : XML;
	//Array to store x	-axis categories (labels)
	private var categories : Array;
	//Array to store datasets
	private var dataset : Array;
	//Total number of data sets
	private var numDS : Number;
	//Number of column, line and area datasets
	private var numColDS : Number;
	private var numLineDS : Number;
	//Number of data items
	private var num : Number;
	//Sum of items
	private var sum:Number;
	//Boolean value to check whether the plotSpacePercent is explicitly defined or calculated as default
	private var defaultPlotSpacePercent : Boolean;
	//Variable to store the instance of the label metrics class.
	private var labelMetrics:LabelMetrics;
	/**
	* Constructor function. We invoke the super class'
	* constructor and then set the objects for this chart.
	*/
	function Pareto2DChart (targetMC : MovieClip, depth : Number, width : Number, height : Number, x : Number, y : Number, debugMode : Boolean, lang : String, scaleMode:String, registerWithJS:Boolean, DOMId:String)
	{
		//Invoke the super class constructor
		super (targetMC, depth, width, height, x, y, debugMode, lang, scaleMode, registerWithJS, DOMId);
		//Log additional information to debugger
		//We log version from this class, so that if this class version
		//is different, we can log it		
		this.log ("Chart Type", "2D Pareto Chart", Logger.LEVEL.INFO);
		_version = getFCVersion();
		this.log ("Version", _version, Logger.LEVEL.INFO);
		//List Chart Objects and set them
		_arrObjects = new Array ("BACKGROUND", "CANVAS", "CAPTION", "SUBCAPTION", "YAXISNAME", "XAXISNAME", "DIVLINES", "YAXISVALUES", "HGRID", "DATALABELS", "DATAVALUES", "TRENDLINES", "TRENDVALUES", "DATAPLOTCOLUMN", "DATAPLOTLINE", "ANCHORS", "TOOLTIP", "VLINES", "VLINELABELS");
		super.setChartObjects (_arrObjects);
		//Initialize the containers for chart
		this.categories = new Array ();
		this.dataset = new Array ();
		//Initialize the number of data elements present
		this.numDS = 0;
		this.numColDS = 0;
		this.numLineDS = 0;
		this.num = 0;
		this.sum = 0;
		//PlotSpacePercent initially considered as explicitly defined.
		this.defaultPlotSpacePercent = false;
		//create the instance
		labelMetrics = new LabelMetrics();
		//set the chart type - for labels management / panel calculation.
		labelMetrics.chartType = "column";
	}
	/**
	* render method is the single call method that does the rendering of chart:
	* - Parsing XML
	* - Calculating values and co-ordinates
	* - Visual layout and rendering
	* - Event handling
	*/
	public function render (isRedraw:Boolean) : Void 
	{
		//reset all variables for label management
		labelMetrics.reset();
		//Parse the XML Data document
		this.parseXML ();
		//If it's a re-draw then do not animate
		if (isRedraw){
			this.params.animation = false;
			this.defaultGlobalAnimation = 0;
		}
		//Now, if the number of data elements is 0, we show pertinent
		//error.
		if (this.numDS * this.num == 0)
		{
			tfAppMsg = this.renderAppMessage (_global.getAppMessage ("NODATA", this.lang));
			//Add a message to log.
			this.log ("No Data to Display", "No data was found in the XML data document provided. Possible cases can be: <LI>There isn't any data generated by your system. If your system generates data based on parameters passed to it using dataURL, please make sure dataURL is URL Encoded.</LI><LI>You might be using a Single Series Chart .swf file instead of Multi-series .swf file and providing multi-series data or vice-versa.</LI>", Logger.LEVEL.ERROR);
			//Expose rendered method
			this.exposeChartRendered();
			//Also raise the no data event
			if (!isRedraw){
				this.raiseNoDataExternalEvent();
			}
		} else 
		{
			//validation for single category item. In case of single category we revert back to previous label management methods
			if(this.num == 1){
				this.params.XTLabelManagement = false;
			}
			//Create the secondary dataset
			this.createSecondaryDataset();
			//Detect number scales
			this.detectNumberScales ();
			//Calculate the axis limits
			this.calculateAxisLimits ();
			//Calculate exact number of div lines
			this.calcDivs ();
			//Set Style defaults
			this.setStyleDefaults ();
			//Validate trend lines
			this.validateTrendLines ();
			//Allot the depths for various charts objects now
			this.allotDepths ();
			//Calculate Points
			this.calculatePoints (isRedraw);
			//Calculate vLine Positions
			this.calcVLinesPos ();
			//Calculate trend line positions
			this.calcTrendLinePos ();
			//Feed macro values
			super.feedMacros ();
			//Remove application message
			this.removeAppMessage (this.tfAppMsg);
			//Set tool tip parameter
			this.setToolTipParam ();
			//-----Start Visual Rendering Now------//
			//Draw background
			this.drawBackground ();
			//Set click handler
			this.drawClickURLHandler ()
			//Load background SWF
			this.loadBgSWF ();
			//Update timer
			this.timeElapsed = (this.params.animation) ? this.styleM.getMaxAnimationTime (this.objects.BACKGROUND) : 0;
			//Draw canvas
			this.config.intervals.canvas = setInterval (Delegate.create (this, drawCanvas) , this.timeElapsed);
			//Draw headers
			this.config.intervals.headers = setInterval (Delegate.create (this, drawHeaders) , this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime (this.objects.CANVAS, this.objects.CAPTION, this.objects.SUBCAPTION, this.objects.YAXISNAME, this.objects.XAXISNAME) : 0;
			//Draw div lines
			this.config.intervals.divLines = setInterval (Delegate.create (this, drawDivLines) , this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime (this.objects.DIVLINES, this.objects.YAXISVALUES) : 0;
			//Horizontal grid
			this.config.intervals.hGrid = setInterval (Delegate.create (this, drawHGrid) , this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime (this.objects.HGRID) : 0;
			//Draw labels
			this.config.intervals.labels = setInterval (Delegate.create (this, drawLabels) , this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime (this.objects.DATALABELS) : 0;
			//Draw columns - if required
			this.config.intervals.plotColumn = setInterval (Delegate.create (this, drawColumns) , this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime (this.objects.DATAPLOTCOLUMN) : 0;
			if (this.params.showCumulativeLine){
				//Draw Lines - if required
				this.config.intervals.plotLine = setInterval (Delegate.create (this, drawLineChart) , this.timeElapsed);
				//Update timer
				this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime (this.objects.DATAPLOTLINE) : 0;
			}
			//Column values
			this.config.intervals.dataValuesColumn = setInterval (Delegate.create (this, drawColumnValues) , this.timeElapsed);
			if (this.params.showCumulativeLine){
				//Line values
				this.config.intervals.dataValuesLine = setInterval (Delegate.create (this, drawLineValues) , this.timeElapsed);
				//Anchors
				this.config.intervals.anchors = setInterval (Delegate.create (this, drawAnchors) , this.timeElapsed);
			}
			//Draw trend lines
			this.config.intervals.trend = setInterval (Delegate.create (this, drawTrendLines) , this.timeElapsed);
			//Draw vertical div lines
			this.config.intervals.vLine = setInterval (Delegate.create (this, drawVLines) , this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime (this.objects.TRENDLINES, this.objects.TRENDVALUES, this.objects.VLINES, this.objects.DATAVALUES, this.objects.ANCHORS) : 0;
			//Dispatch event that the chart has loaded.
			this.config.intervals.renderedEvent = setInterval(Delegate.create(this, exposeChartRendered) , this.timeElapsed);
			//Render context menu
			//We do not put context menu interval as we need the menu to appear
			//right from start of the play.
			this.setContextMenu ();
		}
	}
	/**
	* returnDataAsObject method creates an object out of the parameters
	* passed to this method. The idea is that we store each data point
	* as an object with multiple (flexible) properties. So, we do not
	* use a predefined class structure. Instead we use a generic object.
	*	@param	value		Value for the data.
	*	@param	color		Hex Color code.
	* 	@param	displayValue	Value that will be displayed on the chart
	*	@param	alpha		Alpha of the line
	*	@param	toolText	Tool tip text (if specified).
	*	@param	link		Link (if any) for the data.
	*	@param	showValue	Flag to show/hide value for this data.
	*	@param  valuePosition	Position of value textfield w.r.t line
	*	@param	isDashed	Flag whether the line would be dashed.
	*	@return			An object encapsulating all these properies.
	*/
	private function returnDataAsObject (value : Number, color : String, displayValue:String, alpha : Number, toolText : String, link : String, showValue : Number, valuePosition:String, isDashed : Boolean) : Object 
	{
		//Create a container
		var dataObj : Object = new Object ();
		//Store the values
		dataObj.value = value;
		dataObj.color = color;
		//Explicitly specified display value
		dataObj.exDispVal = displayValue;
		dataObj.alpha = alpha;
		dataObj.toolText = toolText;
		dataObj.link = link;
		dataObj.showValue = (showValue == 1) ? true : false;
		dataObj.valuePosition = valuePosition.toUpperCase();
		dataObj.dashed = isDashed;
		//If the given number is not a valid number or it's missing
		//set appropriate flags for this data point
		dataObj.isDefined = ((dataObj.alpha == 0) || isNaN (value)) ? false : true;
		//Other parameters
		//X & Y Position of data point
		dataObj.x = 0;
		dataObj.y = 0;
		//X & Y Position of value tb
		dataObj.valTBX = 0;
		dataObj.valTBY = 0;
		//Return the container
		return dataObj;
	}
	/**
	* returnDataAsCat method returns data of a <category> element as
	* an object
	*	@param	label		Label of the category.
	*	@param	showLabel	Whether to show the label of this category.
	*	@param	toolText	Tool-text for the category
	*	@return			A container object with the given properties
	*/
	private function returnDataAsCat (label : String, showLabel : Number, toolText : String) : Object
	{
		//Create container object
		var catObj : Object = new Object ();
		catObj.label = label;
		catObj.showLabel = ((showLabel == 1) && (label != undefined) && (label != null) && (label != "")) ? true : false;
		catObj.toolText = toolText;
		//X and Y Position
		catObj.x = 0;
		catObj.y = 0;
		//Return container
		return catObj;
	}
	/**
	* parseXML method parses the XML data, sets defaults and validates
	* the attributes before storing them to data storage objects.
	*/
	private function parseXML () : Void 
	{
		//Get the element nodes
		var arrDocElement : Array = this.xmlData.childNodes;
		//Loop variable
		var i : Number;
		var j : Number;
		var k : Number;
		//Look for <graph> element
		for (i = 0; i < arrDocElement.length; i ++)
		{
			//If it's a <graph> element, proceed.
			//Do case in-sensitive mathcing by changing to upper case
			if (arrDocElement [i].nodeName.toUpperCase () == "GRAPH" || arrDocElement [i].nodeName.toUpperCase () == "CHART")
			{
				//Extract attributes of <graph> element
				this.parseAttributes (arrDocElement [i]);
				//Extract common attributes/over-ride chart specific ones
				this.parseCommonAttributes (arrDocElement [i], true);
				//Now, get the child nodes - first level nodes
				//Level 1 nodes can be - SET, TRENDLINES, STYLES etc.
				var arrLevel1Nodes : Array = arrDocElement [i].childNodes;
				var setNode : XMLNode;
				//Create the primary dataset
				this.numDS ++;
				this.numColDS ++;
				//Create storage object in dataset array
				this.dataset [this.numDS] = new Object ();
				//Create data array under it.
				this.dataset [this.numDS].data = new Array ();
				//Parent y-axis - for main dataset
				this.dataset [this.numDS].parentYAxis = "P";
				//Render as column
				this.dataset [this.numDS].renderAs = "COLUMN";
				//Set default properties for column dataset
				this.dataset [this.numDS].seriesName = "";
				this.dataset [this.numDS].alpha = this.params.plotFillAlpha;
				this.dataset [this.numDS].showValues = this.params.showValues;
				this.dataset [this.numDS].dashed = this.params.plotBorderDashed;
				//Column Border Properties
				this.dataset [this.numDS].showPlotBorder = this.params.showPlotBorder;
				this.dataset [this.numDS].plotBorderColor = this.params.plotBorderColor;
				this.dataset [this.numDS].plotBorderThickness = this.params.plotBorderThickness;
				this.dataset [this.numDS].plotBorderAlpha = this.params.plotBorderAlpha;
				//Iterate through all level 1 nodes.
				for (j = 0; j < arrLevel1Nodes.length; j ++)
				{
					//If it's Data nodes
					if (arrLevel1Nodes [j].nodeName.toUpperCase () == "SET")
					{
						//Set Node. So extract the data.
						//First, updated counter
						this.num ++;
						//Get reference to node.
						setNode = arrLevel1Nodes [j];
						//Get attributes
						var atts : Array;
						atts = this.getAttributesArray (setNode);
						//Extract values.
						var setName : String = getFV (atts ["label"] , atts ["name"] , "");
						//Now, get value - get absolute value, as this is frequency
						var setValue : Number = Math.abs(this.getSetValue (atts ["value"]));
						if (isNaN(setValue)==false){
							//Get explicitly specified display value
							var setExDispVal : String = getFV(atts["displayvalue"], "");
							//We do NOT unescape the link, as this will be done
							//in invokeLink method for the links that user clicks.
							var setLink : String = getFV (atts ["link"] , "");
							var setToolText : String = getFV (atts ["tooltext"] , atts ["hovertext"]);
							/**
							  * When color for the set is explicitly  defined, it will use that color.
							  * Otherwise it will apply pallatte color after sorting data
							**/
							var setColor : String = formatColor  (getFV (atts ["color"], ""));
							//Validate  setColor for space and # only
							setColor = (atts ["color"].length == 1 && (atts ["color"]== " " || atts ["color"] =="#"))? "000000" : setColor;
							var setAlpha : Number = getFN (atts ["alpha"] , this.params.plotFillAlpha);
							var setRatio : String = getFV (atts ["ratio"] , this.params.plotFillRatio);
							var setShowLabel : Number = getFN (atts ["showlabel"] , atts ["showname"] , this.params.showLabels);
							var setShowValue : Number = getFN (atts ["showvalue"] , this.params.showValues);
							var setDashed : Boolean = toBoolean (getFN (atts ["dashed"] , this.params.plotBorderDashed));
							//Store it in data container.
							this.categories [this.num] = this.returnDataAsCat (setName, setShowLabel, setToolText);
							//Store all these attributes as object.
							this.dataset [this.numDS].data [this.num] = this.returnDataAsObject (setValue, setColor, setExDispVal,  setAlpha, setToolText, setLink, setShowValue, this.params.showLineValues, setDashed);
							//Add to sum
							sum += setValue;
						}else{
							this.num--;
						}
						
					} else if (arrLevel1Nodes [j].nodeName.toUpperCase () == "VLINE")
					{
						//Vertical axis division Node - extract child nodes
						var vLineNode : XMLNode = arrLevel1Nodes [j];
						//Parse and store
						this.parseVLineNode (vLineNode, this.num);
					} 
					else if (arrLevel1Nodes [j].nodeName.toUpperCase () == "STYLES")
					{
						//Styles Node - extract child nodes
						var arrStyleNodes : Array = arrLevel1Nodes [j].childNodes;
						//Parse the style nodes to extract style information
						super.parseStyleXML (arrStyleNodes);
					} else if (arrLevel1Nodes [j].nodeName.toUpperCase () == "TRENDLINES")
					{
						//Trend lines node
						var arrTrendNodes : Array = arrLevel1Nodes [j].childNodes;
						//Parse the trend line nodes
						super.parseTrendLineXML (arrTrendNodes);
					}
				}
			}
		}
		//Delete all temporary objects used for parsing XML Data document
		delete setNode;
		delete arrDocElement;
		delete arrLevel1Nodes;
	}
	/**
	* parseAttributes method parses the attributes and stores them in
	* chart storage objects.
	* Starting ActionScript 2, the parsing of XML attributes have also
	* become case-sensitive. However, prior versions of FusionCharts
	* supported case-insensitive attributes. So we need to parse all
	* attributes as case-insensitive to maintain backward compatibility.
	* To do so, we first extract all attributes from XML, convert it into
	* lower case and then store it in an array. Later, we extract value from
	* this array.
	* @param	graphElement	XML Node containing the <graph> element
	*							and it's attributes
	*/
	private function parseAttributes (graphElement : XMLNode) : Void 
	{
		//Array to store the attributes
		var atts : Array = this.getAttributesArray (graphElement);
		//NOW IT'S VERY NECCESARY THAT WHEN WE REFERENCE THIS ARRAY
		//TO GET AN ATTRIBUTE VALUE, WE SHOULD PROVIDE THE ATTRIBUTE
		//NAME IN LOWER CASE. ELSE, UNDEFINED VALUE WOULD SHOW UP.
		//Extract attributes pertinent to this chart
		//Which palette to use?
		this.params.palette = getFN (atts ["palette"] , 1);
		//Palette colors to use
		this.params.paletteColors = getFV(atts["palettecolors"],"");
		//Set palette colors before parsing the <set> nodes.
		this.setPaletteColors();
		// ---------- PADDING AND SPACING RELATED ATTRIBUTES ----------- //
		//captionPadding = Space between caption/subcaption and canvas start Y
		this.params.captionPadding = getFN (atts ["captionpadding"] , 10);
		//Canvas Padding is the space between the canvas left/right border
		//and first/last data point - applicable if 0 columns on chart
		this.params.canvasPadding = getFN (atts ["canvaspadding"] , 0);
		//Padding for x-axis name - from top
		this.params.xAxisNamePadding = getFN (atts ["xaxisnamepadding"] , 5);
		//Padding for y-axis name (both primary and secondary) - to right and left
		this.params.yAxisNamePadding = getFN (atts ["yaxisnamepadding"] , 5);
		//Y-Axis Values padding - Horizontal space between the axis edge and
		//y-axis values or trend line values (on left/right side). Both primary and sec.
		this.params.yAxisValuesPadding = getFN (atts ["yaxisvaluespadding"] , 2);
		//Label padding - Vertical space between the labels and canvas end position
		this.params.labelPadding = getFN (atts ["labelpadding"] , atts ["labelspadding"] , 3);
		//Value padding - vertical space between the end of columns and start of value textboxes
		this.params.valuePadding = getFN (atts ["valuepadding"] , 2);
		//Percentage space on the plot area
		this.params.plotSpacePercent = Number (atts ["plotspacepercent"]);
		///Cannot be less than 0 and more than 80
		if ((this.params.plotSpacePercent < 0) || (this.params.plotSpacePercent > 80) || isNaN(this.params.plotSpacePercent))
		{
			//Reset to 20
			this.params.plotSpacePercent = 20;
			this.defaultPlotSpacePercent = true;
		}
		//Chart Margins - Empty space at the 4 sides
		this.params.chartLeftMargin = getFN (atts ["chartleftmargin"] , 15);
		this.params.chartRightMargin = getFN (atts ["chartrightmargin"] , 15);
		this.params.chartTopMargin = getFN (atts ["charttopmargin"] , 15);
		this.params.chartBottomMargin = getFN (atts ["chartbottommargin"] , 15);
		
		labelMetrics.updateProp("chartObj", {chartWidth: this.width, chartLeftMargin: this.params.chartLeftMargin, chartRightMargin:this.params.chartRightMargin});
		// -------------------------- HEADERS ------------------------- //
		//Chart Caption and sub Caption
		this.params.caption = getFV (atts ["caption"] , "");
		this.params.subCaption = getFV (atts ["subcaption"] , "");
		//X and Y Axis Name
		this.params.xAxisName = getFV (atts ["xaxisname"] , "");
		this.params.PYAxisName = getFV (atts ["pyaxisname"] , "");
		this.params.SYAxisName = getFV (atts ["syaxisname"] , "");
		//Adaptive yMin - if set to true, the y min will be based on the values
		//provided. It won't be set to 0 in case of all positive values
		this.params.setAdaptiveYMin = toBoolean (getFN (atts ["setadaptiveymin"] , 0));
		this.params.setAdaptiveSYMin = false;
		// --------------------- CONFIGURATION ------------------------- //
		//The upper and lower limits of y and x axis
		this.params.PYAxisMinValue = atts ["pyaxisminvalue"];
		this.params.PYAxisMaxValue = atts ["pyaxismaxvalue"];
		//Whether to set animation for entire chart.
		this.params.animation = toBoolean (getFN (this.defaultGlobalAnimation, atts ["animation"] , 1));
		//Whether to set the default chart animation
		this.params.defaultAnimation = toBoolean (getFN (atts ["defaultanimation"] , 1));
		//Whether to show cumulative line-set
		this.params.showCumulativeLine = toBoolean (getFN (atts ["showcumulativeline"] , 1));
		//Whether null data points are to be connected or left broken
		this.params.connectNullData = toBoolean (getFN (atts ["connectnulldata"] , 0));
		//Configuration to set whether to show the labels
		this.params.showLabels = toBoolean (getFN (atts ["showlabels"] , atts ["shownames"] , 1));
		//Label Display Mode - WRAP, STAGGER, ROTATE or NONE
		this.params.labelDisplay = getFV (atts ["labeldisplay"] , "AUTO");
		//Remove spaces and capitalize
		this.params.labelDisplay = StringExt.removeSpaces (this.params.labelDisplay);
		this.params.labelDisplay = this.params.labelDisplay.toUpperCase ();
		//Option to show vertical x-axis labels
		this.params.rotateLabels = getFV (atts ["rotatelabels"] , atts ["rotatenames"]);
		//Whether to slant label (if rotated)
		this.params.slantLabels = toBoolean (getFN (atts ["slantlabels"] , atts ["slantlabel"] , 0));
		//Angle of rotation based on slanting
		this.config.labelAngle = (this.params.slantLabels == true) ? 315 : 270;
		//If rotateLabels has been explicitly specified, we assign ROTATE value to this.params.labelDisplay
		this.params.labelDisplay = (this.params.rotateLabels == "1") ? "ROTATE" : this.params.labelDisplay;
		//Step value for labels - i.e., show all labels or skip every x label
		this.params.labelStep = int (getFN (atts ["labelstep"] , 1));
		//Cannot be less than 1
		this.params.labelStep = (this.params.labelStep < 1) ? 1 : this.params.labelStep;
		//Number of stagger lines
		this.params.staggerLines = int (getFN (atts ["staggerlines"] , 2));
		//Cannot be less than 2
		this.params.staggerLines = (this.params.staggerLines < 2) ? 2 : this.params.staggerLines;
		//Configuration whether to show data values
		this.params.showValues = toBoolean (getFN (atts ["showvalues"] , 1));
		this.params.showLineValues = toBoolean (getFN (atts ["showlinevalues"] , (this.params.showValues)?1:0));
		//Value position
		this.params.valuePosition = getFV(atts ["valueposition"], "AUTO");
		//Whether to rotate values
		this.params.rotateValues = toBoolean (getFN (atts ["rotatevalues"] , 0));
		//Whether to place values inside column
		this.params.placeValuesInside = toBoolean (getFN (atts ["placevaluesinside"] , 0));
		//Option to show/hide y-axis values
		this.params.showYAxisValues = getFN (atts ["showyaxisvalues"] , atts ["showyaxisvalue"] , 1);
		this.params.showLimits = toBoolean (getFN (atts ["showlimits"] , this.params.showYAxisValues));
		this.params.showDivLineValues = toBoolean (getFN (atts ["showdivlinevalue"] , atts ["showdivlinevalues"] , this.params.showYAxisValues));
		this.params.showPZeroPlaneValue = atts ["showpzeroplanevalue"];
		this.params.showPZeroPlaneValue = (this.params.showPZeroPlaneValue == 0 || this.params.showPZeroPlaneValue == 1 )? toBoolean(this.params.showPZeroPlaneValue) : undefined;
		
		//Secondary axis limits and div line values
		this.params.showSecondaryLimits = toBoolean (getFN (atts ["showsecondarylimits"] , this.params.showCumulativeLine));
		this.params.showDivLineSecondaryValue = toBoolean (getFN (atts ["showdivlinesecondaryvalue"] , this.params.showCumulativeLine));
		this.params.showSZeroPlaneValue = atts ["showszeroplanevalue"];
		this.params.showSZeroPlaneValue = (this.params.showSZeroPlaneValue == 0 || this.params.showSZeroPlaneValue == 1 )? toBoolean(this.params.showSZeroPlaneValue) : undefined;
		
		//Y-axis value step- i.e., show all y-axis or skip every x(th) value
		this.params.yAxisValuesStep = int (getFN (atts ["yaxisvaluesstep"] , atts ["yaxisvaluestep"] , 1));
		//Cannot be less than 1
		this.params.yAxisValuesStep = (this.params.yAxisValuesStep < 1) ? 1 : this.params.yAxisValuesStep;
		//Show shadow
		this.params.showShadow = toBoolean (getFN (atts ["showshadow"] , this.defColors.get2DShadow (this.params.palette)));
		//Whether to automatically adjust div lines
		this.params.adjustDiv = toBoolean (getFN (atts ["adjustdiv"] , 1));
		//Whether to rotate y-axis names
		this.params.rotateYAxisName = toBoolean (getFN (atts ["rotateyaxisname"] , 1));
		//Max width to be alloted to y-axis name - No defaults, as it's calculated later.
		this.params.PYAxisNameWidth = (this.params.PYAxisName != undefined && this.params.PYAxisName != "" ) ? atts ["pyaxisnamewidth"] : 0;
		this.params.SYAxisNameWidth = (this.params.SYAxisName != undefined && this.params.SYAxisName != "" ) ? atts ["syaxisnamewidth"] : 0;
		//Click URL
		this.params.clickURL = getFV (atts ["clickurl"] , "");
		// ------------------------- COSMETICS -----------------------------//
		//Background properties - Gradient
		this.params.bgColor = getFV (atts ["bgcolor"] , this.defColors.get2DBgColor (this.params.palette));
		this.params.bgAlpha = getFV (atts ["bgalpha"] , this.defColors.get2DBgAlpha (this.params.palette));
		this.params.bgRatio = getFV (atts ["bgratio"] , this.defColors.get2DBgRatio (this.params.palette));
		this.params.bgAngle = getFV (atts ["bgangle"] , this.defColors.get2DBgAngle (this.params.palette));
		//Border Properties of chart
		this.params.showBorder = toBoolean (getFN (atts ["showborder"] , 1));
		this.params.borderColor = formatColor (getFV (atts ["bordercolor"] , this.defColors.get2DBorderColor (this.params.palette)));
		this.params.borderThickness = getFN (atts ["borderthickness"] , 1);
		this.params.borderAlpha = getFN (atts ["borderalpha"] , this.defColors.get2DBorderAlpha (this.params.palette));
		//Canvas background properties - Gradient
		this.params.canvasBgColor = getFV (atts ["canvasbgcolor"] , this.defColors.get2DCanvasBgColor (this.params.palette));
		this.params.canvasBgAlpha = getFV (atts ["canvasbgalpha"] , this.defColors.get2DCanvasBgAlpha (this.params.palette));
		this.params.canvasBgRatio = getFV (atts ["canvasbgratio"] , this.defColors.get2DCanvasBgRatio (this.params.palette));
		this.params.canvasBgAngle = getFV (atts ["canvasbgangle"] , this.defColors.get2DCanvasBgAngle (this.params.palette));
		//Canvas Border properties
		this.params.canvasBorderColor = formatColor (getFV (atts ["canvasbordercolor"] , this.defColors.get2DCanvasBorderColor (this.params.palette)));
		this.params.canvasBorderThickness = getFN (atts ["canvasborderthickness"] , 2);
		this.params.canvasBorderAlpha = getFN (atts ["canvasborderalpha"] , this.defColors.get2DCanvasBorderAlpha (this.params.palette));
		//Whether to use round edges?
		this.params.useRoundEdges = getFN (atts ["useroundedges"] , 0);
		//Plot Properties - Column and Area.
		//Plot cosmetic properties
		this.params.showPlotBorder = toBoolean (getFN (atts ["showplotborder"] , 1));
		this.params.plotBorderColor = formatColor (getFV (atts ["plotbordercolor"] , this.defColors.get2DPlotBorderColor (this.params.palette)));
		this.params.plotBorderThickness = getFN (atts ["plotborderthickness"] , (this.params.useRoundEdges)?0:1);
		this.params.plotBorderAlpha = getFN (atts ["plotborderalpha"] , 100);
		//If showPlotBorder is false  set the plotBorderAlpha to 0 value.
		this.params.plotBorderAlpha = (this.params.showPlotBorder == true) ? this.params.plotBorderAlpha : 0 ;
		//Plot is dashed??
		this.params.plotBorderDashed = toBoolean (getFN (atts ["plotborderdashed"] , 0));
		//Dash Properties
		this.params.plotBorderDashLen = getFN (atts ["plotborderdashlen"] , 5);
		this.params.plotBorderDashGap = getFN (atts ["plotborderdashgap"] , 4);
		//Fill properties
		this.params.plotFillAngle = getFN (atts ["plotfillangle"] , 270);
		this.params.plotFillAlpha = getFN (atts ["plotfillalpha"] , 100);
		//Plot gradient color
		if (atts ["plotgradientcolor"] == "")
		{
			//If some one doesn't want to specify a plot gradient color
			//i.e., he opts for solid fills
			this.params.plotGradientColor = ""
		}else
		{
			this.params.plotGradientColor = formatColor (getFV (atts ["plotgradientcolor"] , this.defColors.get2DPlotGradientColor (this.params.palette)));
		}
		//added attribute to control plotGradientColor. As the default behaviour of any blank attribute is to revert to the default attribute.
		//Since V 3.2.2 - sr3 - we discourage using plotGradientColor with blank ("") value.
		this.params.usePlotGradientColor = toBoolean ( getFN ( atts['useplotgradientcolor'], 1));
		if(!this.params.usePlotGradientColor){
			this.params.plotGradientColor = "";
		}
		//Line Properties
		this.params.lineColor = formatColor (getFV(atts ["linecolor"], this.defColors.get2DPlotBorderColor (this.params.palette)));
		this.params.lineThickness = getFN (atts ["linethickness"] , 2);
		this.params.lineAlpha = getFN (atts ["linealpha"] , 100);
		this.params.lineDashed = toBoolean (getFN (atts ["linedashed"] , 0));
		this.params.lineDashLen = getFN (atts ["linedashlen"] , 5);
		this.params.lineDashGap = getFN (atts ["linedashgap"] , 4);
		//Horizontal grid division Lines - Number, color, thickness & alpha
		//Necessarily need a default value for numDivLines.
		this.params.numDivLines = getFN (atts ["numdivlines"] , 4);
		this.params.divLineColor = formatColor (getFV (atts ["divlinecolor"] , this.defColors.get2DDivLineColor (this.params.palette)));
		this.params.divLineThickness = getFN (atts ["divlinethickness"] , 1);
		this.params.divLineAlpha = getFN (atts ["divlinealpha"] , this.defColors.get2DDivLineAlpha (this.params.palette));
		this.params.divLineIsDashed = toBoolean (getFN (atts ["divlineisdashed"] , 0));
		this.params.divLineDashLen = getFN (atts ["divlinedashlen"] , 4);
		this.params.divLineDashGap = getFN (atts ["divlinedashgap"] , 2);
		//Zero Plane properties
		this.params.showZeroPlane = true;
		this.params.zeroPlaneColor = formatColor (getFV (atts ["zeroplanecolor"] , this.params.divLineColor));
		this.params.zeroPlaneThickness = getFN (atts ["zeroplanethickness"] , (this.params.divLineThickness == 1) ?2 : this.params.divLineThickness);
		this.params.zeroPlaneAlpha = getFN (atts ["zeroplanealpha"] , this.params.divLineAlpha * 2);
		//Alternating grid colors
		this.params.showAlternateHGridColor = toBoolean (getFN (atts ["showalternatehgridcolor"] , 1));
		this.params.alternateHGridColor = formatColor (getFV (atts ["alternatehgridcolor"] , this.defColors.get2DAltHGridColor (this.params.palette)));
		this.params.alternateHGridAlpha = getFN (atts ["alternatehgridalpha"] , this.defColors.get2DAltHGridAlpha (this.params.palette));
		//Anchor Properties
		this.params.drawAnchors = toBoolean (getFN (atts ["drawanchors"] , atts ["showanchors"] , 1));
		this.params.anchorSides = getFN (atts ["anchorsides"] , 0);
		this.params.anchorRadius = getFN (atts ["anchorradius"] , 3);
		this.params.anchorBorderColor = formatColor (getFV (atts ["anchorbordercolor"] , this.params.lineColor,this.defColors.get2DPlotBorderColor (this.params.palette)));    
		this.params.anchorBorderThickness = getFN (atts ["anchorborderthickness"] , 1);
		this.params.anchorBgColor = formatColor (getFV (atts ["anchorbgcolor"] , this.defColors.get2DAnchorBgColor (this.params.palette)));
		this.params.anchorAlpha = getFN (atts ["anchoralpha"] , 100);
		this.params.anchorBgAlpha = getFN (atts ["anchorbgalpha"] , this.params.anchorAlpha);
		// ------------------------- NUMBER FORMATTING ---------------------------- //
		//Option whether the format the number (using Commas)
		this.params.formatNumber = toBoolean (getFN (atts ["formatnumber"] , 1));
		//Option to format number scale
		this.params.formatNumberScale = toBoolean (getFN (atts ["formatnumberscale"] , 1));
		//Number Scales
		this.params.defaultNumberScale = getFV (atts ["defaultnumberscale"] , "");
		this.params.numberScaleUnit = getFV (atts ["numberscaleunit"] , "K,M");
		this.params.numberScaleValue = getFV (atts ["numberscalevalue"] , "1000,1000");
		//Number prefix and suffix
		this.params.numberPrefix = getFV (atts ["numberprefix"] , "");
		this.params.numberSuffix = getFV (atts ["numbersuffix"] , "");
		//whether to scale recursively
		this.params.scaleRecursively = toBoolean( getFN (atts ['scalerecursively'], 0));
		//By default we show all - so set as -1
		this.params.maxScaleRecursion = getFN(atts["maxscalerecursion"], -1);
		//Setting space as default scale separator.
		this.params.scaleSeparator = getFV(atts["scaleseparator"] , " ");
		//Decimal Separator Character
		this.params.decimalSeparator = getFV (atts ["decimalseparator"] , ".");
		//Thousand Separator Character
		this.params.thousandSeparator = getFV (atts ["thousandseparator"] , ",");
		//Input decimal separator and thousand separator. In some european countries,
		//commas are used as decimal separators and dots as thousand separators. In XML,
		//if the user specifies such values, it will give a error while converting to
		//number. So, we accept the input decimal and thousand separator from user, so that
		//we can covert it accordingly into the required format.
		this.params.inDecimalSeparator = getFV (atts ["indecimalseparator"] , "");
		this.params.inThousandSeparator = getFV (atts ["inthousandseparator"] , "");
		//Decimal Precision (number of decimal places to be rounded to)
		this.params.decimals = getFV (atts ["decimals"] , atts ["decimalprecision"]);
		//Force Decimal Padding
		this.params.forceDecimals = toBoolean (getFN (atts ["forcedecimals"] , 0));
		//y-Axis values decimals
		this.params.yAxisValueDecimals = getFV (atts ["yaxisvaluedecimals"] , atts ["yaxisvaluesdecimals"] , atts ["divlinedecimalprecision"] , atts ["limitsdecimalprecision"]);
		// ---------------- SECONDARY AXIS NUMBER FORMATTING --------------------- //
		this.params.sFormatNumber = true;
		this.params.sFormatNumberScale = false;
		this.params.sDefaultNumberScale = "";
		this.params.sNumberScaleUnit = "";
		this.params.sNumberScaleValue = "";
		this.params.sNumberPrefix = "";
		this.params.sNumberSuffix = "%";
		this.params.sDecimals = getFV (atts ["sdecimals"] , this.params.decimals);
		this.params.sForceDecimals = toBoolean (getFN (atts ["sforcedecimals"] , (this.params.forceDecimals) ?1 : 0));
		this.params.sYAxisValueDecimals = getFN (atts ["syaxisvaluedecimals"] , this.params.sDecimals);
	}
	/**
	 * Creates the secondary dataset for the pareto chart, based on the primary
	*/
	private function createSecondaryDataset():Void{
		//First sort the primary dataset based on value.
		var i:Number, cumValue:Number=0;
		var percentCumValue:Number;		
		//Sort the dataset in descending order - bubble sort
		//Sort categories in the same order.
		var changed:Boolean = false;
		while (!changed)
		{
			changed = true;
			for (var i:Number = 1; i < this.num; i++)
			{
				if (this.dataset[this.numDS].data[i].value < this.dataset[this.numDS].data[i+1].value)
				{
					//Swap data object
					var tmp:Object = this.dataset[this.numDS].data[i];
					this.dataset[this.numDS].data[i] = this.dataset[this.numDS].data[i+1];
					this.dataset[this.numDS].data[i+1] = tmp;
	 				//Swap categories
					var tmpCat:Object = this.categories[i];
					this.categories[i] = this.categories[i+1];
					this.categories[i+1] = tmpCat;
					changed = false;
				}
			}
		}
		//Apply Pallette color after sorting data
		for (var i:Number = 1; i <=this.num; i++){
			//When color is not explicitly defined set it to pallette color 
			if( this.dataset[this.numDS].data[i].color == ""){
				this.dataset[this.numDS].data[i].color = this.defColors.getColor();
			}else{
				//Shift one index in color palette
				var arrayColorShift:String = this.defColors.getColor();
			}
		}
		//Now that the data is sorted, create another line-set (if to be shown)
		if (this.params.showCumulativeLine){
			//Loop variable
			var i:Number;
			//Create the secondary dataset
			this.numDS++;
			this.numLineDS++;
			//Create storage object in dataset array
			this.dataset[this.numDS] = new Object ();
			//Create data array under it.
			this.dataset[this.numDS].data = new Array ();
			//Secondary y-axis - for secondary dataset
			this.dataset[this.numDS].parentYAxis = "S";
			//Render as line
			this.dataset[this.numDS].renderAs = "LINE";
			//Set default properties for column dataset
			this.dataset[this.numDS].seriesName = "";
			this.dataset[this.numDS].alpha = this.params.lineAlpha;
			this.dataset[this.numDS].showValues = this.params.showValues;
			this.dataset[this.numDS].valuePosition = this.params.valuePosition;
			this.dataset[this.numDS].dashed = this.params.lineDashed;
			//Column Border Properties
			this.dataset[this.numDS].showPlotBorder = this.params.showPlotBorder;
			this.dataset[this.numDS].plotBorderColor = this.params.plotBorderColor;
			this.dataset[this.numDS].plotBorderThickness = this.params.plotBorderThickness;
			this.dataset[this.numDS].plotBorderAlpha = this.params.plotBorderAlpha;
			//Calculate the cumulative % now and store
			for (i=1; i<=this.num; i++){
				//Calculate the cumulative value
				cumValue += this.dataset [this.numColDS].data[i].value;
				//Calculate the %
				percentCumValue = (cumValue/this.sum)*100;
				//Last value has to be 100
				if (i==this.num){
					percentCumValue = 100;					
				}
				//Store all these attributes as object.
				this.dataset[this.numDS].data [i] = this.returnDataAsObject (percentCumValue, this.params.lineColor, "", this.params.lineAlpha, this.dataset [this.numColDS].data[i].toolText, this.dataset [this.numColDS].data[i].link, this.dataset [this.numColDS].data[i].showValue, this.dataset[this.numDS].valuePosition, this.params.lineDashed);
			}
		}		
	}
	/**
	* getMaxDataValue method gets the maximum y-axis data value present
	* in the data.
	*	@param		Parent Y Axis
	*	@return	The maximum value present in the data provided.
	*/
	private function getMaxDataValue (parentYAxis : String) : Number 
	{
		var maxValue : Number;
		var firstNumberFound : Boolean = false;
		var i : Number, j : Number;
		for (i = 1; i <= this.numDS; i ++)
		{
			if (this.dataset [i].parentYAxis == parentYAxis)
			{
				for (j = 1; j <= this.num; j ++)
				{
					//By default assume the first non-null number to be maximum
					if (firstNumberFound == false)
					{
						if (this.dataset [i].data [j].isDefined == true)
						{
							//Set the flag that "We've found first non-null number".
							firstNumberFound = true;
							//Also assume this value to be maximum.
							maxValue = this.dataset [i].data [j].value;
						}
					} else 
					{
						//If the first number has been found and the current data is defined, compare
						if (this.dataset [i].data [j].isDefined)
						{
							//Store the greater number
							maxValue = (this.dataset [i].data [j].value > maxValue) ? this.dataset [i].data [j].value : maxValue;
						}
					}
				}
			}
		}
		return maxValue;
	}
	/**
	* getMinDataValue method gets the minimum y-axis data value present
	* in the data
	*	@param		Parent Y Axis
	*	@reurns		The minimum value present in data
	*/
	private function getMinDataValue (parentYAxis : String) : Number 
	{
		var minValue : Number;
		var firstNumberFound : Boolean = false;
		var i : Number, j : Number;
		for (i = 1; i <= this.numDS; i ++)
		{
			if (this.dataset [i].parentYAxis == parentYAxis)
			{
				for (j = 1; j <= this.num; j ++)
				{
					//By default assume the first non-null number to be minimum
					if (firstNumberFound == false)
					{
						if (this.dataset [i].data [j].isDefined == true)
						{
							//Set the flag that "We've found first non-null number".
							firstNumberFound = true;
							//Also assume this value to be minimum.
							minValue = this.dataset [i].data [j].value;
						}
					} else 
					{
						//If the first number has been found and the current data is defined, compare
						if (this.dataset [i].data [j].isDefined)
						{
							//Store the lesser number
							minValue = (this.dataset [i].data [j].value < minValue) ? this.dataset [i].data [j].value : minValue;
						}
					}
				}
			}
		}
		return minValue;
	}
	/**
	* calculateAxisLimits method sets the axis limits for the chart.
	* It gets the minimum and maximum value specified in data and
	* based on that it calls super.getAxisLimits();
	*/
	private function calculateAxisLimits () : Void 
	{
		this.getPAxisLimits (this.getMaxDataValue ("P") , this.getMinDataValue ("P") , ! this.params.setAdaptiveYMin);
		//Set secondary axis as 0,100
		this.params.SYAxisMinValue=0;
		this.params.SYAxisMaxValue=100;
		this.getSAxisLimits (100 , 0 , ! this.params.setAdaptiveSYMin);
	}
	/**
	* setStyleDefaults method sets the default values for styles or
	* extracts information from the attributes and stores them into
	* style objects.
	*/
	private function setStyleDefaults () : Void 
	{
		//Default font object for Caption
		//-----------------------------------------------------------------//
		var captionFont = new StyleObject ();
		captionFont.name = "_SdCaptionFont";
		captionFont.align = "center";
		captionFont.valign = "top";
		captionFont.bold = "1";
		captionFont.font = this.params.outCnvBaseFont;
		captionFont.size = this.params.outCnvBaseFontSize+3;
		captionFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.CAPTION, captionFont, this.styleM.TYPE.FONT, null);
		delete captionFont;
		//-----------------------------------------------------------------//
		//Default font object for SubCaption
		//-----------------------------------------------------------------//
		var subCaptionFont = new StyleObject ();
		subCaptionFont.name = "_SdSubCaptionFont";
		subCaptionFont.align = "center";
		subCaptionFont.valign = "top";
		subCaptionFont.bold = "1";
		subCaptionFont.font = this.params.outCnvBaseFont;
		subCaptionFont.size = this.params.outCnvBaseFontSize+1;
		subCaptionFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.SUBCAPTION, subCaptionFont, this.styleM.TYPE.FONT, null);
		delete subCaptionFont;
		//-----------------------------------------------------------------//
		//Default font object for YAxisName
		//-----------------------------------------------------------------//
		var yAxisNameFont = new StyleObject ();
		yAxisNameFont.name = "_SdYAxisNameFont";
		yAxisNameFont.align = "center";
		yAxisNameFont.valign = "middle";
		yAxisNameFont.bold = "1";
		yAxisNameFont.font = this.params.outCnvBaseFont;
		yAxisNameFont.size = this.params.outCnvBaseFontSize;
		yAxisNameFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.YAXISNAME, yAxisNameFont, this.styleM.TYPE.FONT, null);
		delete yAxisNameFont;
		//-----------------------------------------------------------------//
		//Default font object for XAxisName
		//-----------------------------------------------------------------//
		var xAxisNameFont = new StyleObject ();
		xAxisNameFont.name = "_SdXAxisNameFont";
		xAxisNameFont.align = "center";
		xAxisNameFont.valign = "middle";
		xAxisNameFont.bold = "1";
		xAxisNameFont.font = this.params.outCnvBaseFont;
		xAxisNameFont.size = this.params.outCnvBaseFontSize;
		xAxisNameFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.XAXISNAME, xAxisNameFont, this.styleM.TYPE.FONT, null);
		delete xAxisNameFont;
		//-----------------------------------------------------------------//
		//Default font object for trend lines
		//-----------------------------------------------------------------//
		var trendFont = new StyleObject ();
		trendFont.name = "_SdTrendFontFont";
		trendFont.font = this.params.outCnvBaseFont;
		trendFont.size = this.params.outCnvBaseFontSize;
		trendFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.TRENDVALUES, trendFont, this.styleM.TYPE.FONT, null);
		delete trendFont;
		//-----------------------------------------------------------------//
		//Default font object for yAxisValues
		//-----------------------------------------------------------------//
		var yAxisValuesFont = new StyleObject ();
		yAxisValuesFont.name = "_SdYAxisValuesFont";
		yAxisValuesFont.align = "right";
		yAxisValuesFont.valign = "middle";
		yAxisValuesFont.font = this.params.outCnvBaseFont;
		yAxisValuesFont.size = this.params.outCnvBaseFontSize;
		yAxisValuesFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.YAXISVALUES, yAxisValuesFont, this.styleM.TYPE.FONT, null);
		delete yAxisValuesFont;
		//-----------------------------------------------------------------//
		//Default font object for DataLabels
		//-----------------------------------------------------------------//
		var dataLabelsFont = new StyleObject ();
		dataLabelsFont.name = "_SdDataLabelsFont";
		dataLabelsFont.align = "center";
		dataLabelsFont.valign = "bottom";
		dataLabelsFont.font = this.params.outCnvBaseFont;
		dataLabelsFont.size = this.params.outCnvBaseFontSize;
		dataLabelsFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.DATALABELS, dataLabelsFont, this.styleM.TYPE.FONT, null);
		delete dataLabelsFont;
		//-----------------------------------------------------------------//
		//Default font object for DataValues
		//-----------------------------------------------------------------//
		var dataValuesFont = new StyleObject ();
		dataValuesFont.name = "_SdDataValuesFont";
		dataValuesFont.align = "center";
		dataValuesFont.valign = "middle";
		dataValuesFont.font = this.params.baseFont;
		dataValuesFont.size = this.params.baseFontSize;
		dataValuesFont.color = this.params.baseFontColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.DATAVALUES, dataValuesFont, this.styleM.TYPE.FONT, null);
		delete dataValuesFont;
		//-----------------------------------------------------------------//
		//Default font object for ToolTip
		//-----------------------------------------------------------------//
		var toolTipFont = new StyleObject ();
		toolTipFont.name = "_SdToolTipFont";
		toolTipFont.font = this.params.baseFont;
		toolTipFont.size = this.params.baseFontSize;
		toolTipFont.color = this.params.baseFontColor;
		toolTipFont.bgcolor = this.params.toolTipBgColor;
		toolTipFont.bordercolor = this.params.toolTipBorderColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.TOOLTIP, toolTipFont, this.styleM.TYPE.FONT, null);
		delete toolTipFont;
		//-----------------------------------------------------------------//
		//Default font object for V-line labels
		//-----------------------------------------------------------------//
		var vLineLabelsFont = new StyleObject ();
		vLineLabelsFont.name = "_SdDataVLineLabelsFont";
		vLineLabelsFont.align = "center";
		vLineLabelsFont.valign = "bottom";
		vLineLabelsFont.font = this.params.baseFont;
		vLineLabelsFont.size = this.params.baseFontSize;
		vLineLabelsFont.color = this.params.baseFontColor;
		vLineLabelsFont.bgcolor = this.params.canvasBgColor;
		//Over-ride
		this.styleM.overrideStyle (this.objects.VLINELABELS, vLineLabelsFont, this.styleM.TYPE.FONT, null);
		delete vLineLabelsFont;
		//-----------------------------------------------------------------//
		//Default Effect (Shadow) object for DataPlots
		//-----------------------------------------------------------------//
		if (this.params.showShadow || this.params.useRoundEdges)
		{
			var dataPlotShadow = new StyleObject ();
			dataPlotShadow.name = "_SdDataPlotShadow";
			dataPlotShadow.distance = 2;
			dataPlotShadow.angle = 45;
			//Over-ride
			this.styleM.overrideStyle (this.objects.DATAPLOTCOLUMN, dataPlotShadow, this.styleM.TYPE.SHADOW, null);
			if (this.params.showShadow){
				//Set shadows on line and area only if required.
				this.styleM.overrideStyle (this.objects.DATAPLOTLINE, dataPlotShadow, this.styleM.TYPE.SHADOW, null);
				//Intentionally not applying shadow to area if any columns are present as it will distort view
				//Or we apply shadow if the areas are below columns
				if (this.numColDS == 0)
				{
					this.styleM.overrideStyle (this.objects.DATAPLOTAREA, dataPlotShadow, this.styleM.TYPE.SHADOW, null);
				}
			}
			delete dataPlotShadow;
		}
		//Also, if round edges are to be plotted, we need a shadow object for canvas
		if (this.params.useRoundEdges){
			var canvasShadow = new StyleObject ();
			canvasShadow.name = "_SdCanvasShadow";
			canvasShadow.distance = 0;
			canvasShadow.blurx = 8;
			canvasShadow.blury = 8;
			canvasShadow.alpha = 90;
			canvasShadow.angle = 45;
			//Over-ride
			this.styleM.overrideStyle (this.objects.CANVAS, canvasShadow, this.styleM.TYPE.SHADOW, null);
			delete canvasShadow;
		}
		//-----------------------------------------------------------------//
		//Default Animation object for DataPlots (if required)
		//-----------------------------------------------------------------//
		if (this.params.defaultAnimation)
		{
			var dataPlotAnim = new StyleObject ();
			dataPlotAnim.name = "_SdDataPlotColumnAnim";
			dataPlotAnim.param = "_yscale";
			dataPlotAnim.easing = "regular";
			dataPlotAnim.wait = 0;
			dataPlotAnim.start = 0;
			dataPlotAnim.duration = 1;
			//Over-ride
			this.styleM.overrideStyle (this.objects.DATAPLOTCOLUMN, dataPlotAnim, this.styleM.TYPE.ANIMATION, "_yscale");
			delete dataPlotAnim;
			// Alpha effect for anchors - Line and area
			var anchorsAnim = new StyleObject ();
			anchorsAnim.name = "_SdDataAnchorAnim";
			anchorsAnim.param = "_alpha";
			anchorsAnim.easing = "regular";
			anchorsAnim.wait = 0;
			anchorsAnim.start = 0;
			anchorsAnim.duration = 0.5;
			//Over-ride
			this.styleM.overrideStyle (this.objects.ANCHORS, anchorsAnim, this.styleM.TYPE.ANIMATION, "_alpha");
			delete anchorsAnim;
			//For Line - 2 animation effects - xScale and subsequent yScale
			var dataPlotAnimLineX = new StyleObject ();
			dataPlotAnimLineX.name = "_SdDataPlotLineAnimXScale";
			dataPlotAnimLineX.param = "_xscale";
			dataPlotAnimLineX.easing = "regular";
			dataPlotAnimLineX.wait = 0;
			dataPlotAnimLineX.start = 0;
			dataPlotAnimLineX.duration = 0.7;
			//Over-ride
			this.styleM.overrideStyle (this.objects.DATAPLOTLINE, dataPlotAnimLineX, this.styleM.TYPE.ANIMATION, "_xscale");
			delete dataPlotAnimLineX;
			//YScale for line
			var dataPlotAnimLineY = new StyleObject ();
			dataPlotAnimLineY.name = "_SdDataPlotLineAnimYScale";
			dataPlotAnimLineY.param = "_yscale";
			dataPlotAnimLineY.easing = "regular";
			dataPlotAnimLineY.wait = 0.7;
			dataPlotAnimLineY.start = 0.1;
			dataPlotAnimLineY.duration = 0.7;
			//Over-ride
			this.styleM.overrideStyle (this.objects.DATAPLOTLINE, dataPlotAnimLineY, this.styleM.TYPE.ANIMATION, "_yscale");
			delete dataPlotAnimLineY;
		}
		//-----------------------------------------------------------------//
		
	}
	/**
	* calcVLinesPos method calculates the x position for the various
	* vLines defined. Also, it validates them.
	*/
	private function calcVLinesPos ()
	{
		var i : Number;
		//Iterate through all the vLines
		for (i = 1; i <= numVLines; i ++)
		{
			//If the vLine is after 1st data and before last data
			if (this.vLines [i].index > 0 && this.vLines [i].index < this.num)
			{
				//Set it's x position
				this.vLines [i].x = this.categories [this.vLines [i].index].x + (this.categories [this.vLines [i].index + 1].x - this.categories [this.vLines [i].index].x)  * this.vLines[i].linePosition;
			} else 
			{
				//Invalidate it
				this.vLines [i].isValid = false;
			}
		}
	}
	/**
	* calculatePoints method calculates the various points on the chart.
	*/
	private function calculatePoints (isRedraw:Boolean)
	{
		//Loop variable
		var i : Number, j : Number;
		//Feed empty data - By default there should be equal number of <categories>
		//and <set> element within each dataset. If in case, <set> elements fall short,
		//we need to append empty data at the end.
		for (i = 1; i <= this.numDS; i ++)
		{
			for (j = 1; j <= this.num; j ++)
			{
				if (this.dataset [i].data [j] == undefined)
				{
					this.dataset [i].data [j] = this.returnDataAsObject (NaN);
				}
			}
		}
		//Format all the numbers on the chart and store their display values
		//We format and store here itself, so that later, whenever needed,
		//we just access displayValue instead of formatting once again.
		//Also set tool tip text values
		var toolText : String
		for (i = 1; i <= this.numDS; i ++)
		{
			for (j = 1; j <= this.num; j ++)
			{
				if (this.dataset [i].parentYAxis == "P")
				{
					//Format and store
					this.dataset [i].data [j].displayValue = formatNumber (this.dataset [i].data [j].value, this.params.formatNumber, this.params.decimals, this.params.forceDecimals, this.params.formatNumberScale, this.params.defaultNumberScale, this.config.nsv, this.config.nsu, this.params.numberPrefix, this.params.numberSuffix, this.params.scaleRecursively, this.params.scaleSeparator, this.params.maxScaleRecursion);
				}else
				{
					this.dataset [i].data [j].displayValue = formatNumber (this.dataset [i].data [j].value, this.params.sFormatNumber, this.params.sDecimals, this.params.sForceDecimals, this.params.sFormatNumberScale, this.params.sDefaultNumberScale, this.config.snsv, this.config.snsu, this.params.sNumberPrefix, this.params.sNumberSuffix, this.params.scaleRecursively, this.params.scaleSeparator, this.params.maxScaleRecursion);
				}
				//Store formatted values
				this.dataset [i].data [j].formattedValue = this.dataset [i].data [j].displayValue;
				//Tool tip text.
				//Preferential Order - Set Tool Text (No concatenation) > SeriesName + Cat Name + Value
				if (this.dataset [i].data [j].toolText == undefined || this.dataset [i].data [j].toolText == "")
				{
					//If the tool tip text is not already defined
					//If labels have been defined
					toolText = (this.params.seriesNameInToolTip && this.dataset [i].seriesName != "") ? (this.dataset [i].seriesName + this.params.toolTipSepChar) : "";
					toolText = toolText + ((this.categories[j].label != "") ? (this.categories[j].label + this.params.toolTipSepChar) : "");
					toolText = toolText + this.dataset [i].data [j].displayValue;
					this.dataset [i].data [j].toolText = toolText;
				}
				if (this.dataset[i].data[j].exDispVal != "") {
					this.dataset[i].data[j].displayValue = this.dataset[i].data[j].exDispVal;
				}
			}
		}
		//We now need to calculate the available Width on the canvas.
		//Available width = total Chart width minus the list below
		// - Left and Right Margin
		// - Primary axis yAxisName (if to be shown)
		// - Primary axis yAxisValues
		// - Trend line display values (both primary and secondary).
		// - Secondary axis yAxisValues
		// - Secondary axis yAxisName
		var canvasWidth : Number = this.width - (this.params.chartLeftMargin + this.params.chartRightMargin);
		//Set canvas startX
		var canvasStartX : Number = this.params.chartLeftMargin;
		//Now, if y-axis name is to be shown, simulate it and get the width
		if (this.params.PYAxisName != "")
		{
			//Get style object
			var yAxisNameStyle : Object = this.styleM.getTextStyle (this.objects.YAXISNAME);
			if (this.params.rotateYAxisName)
			{
				//Create text field to get width
				var yAxisNameObj : Object = createText (true, this.params.PYAxisName, this.tfTestMC, 1, testTFX, testTFY, 90, yAxisNameStyle, true, this.height-(this.params.chartTopMargin+this.params.chartBottomMargin), canvasWidth/3);
				//Accomodate width and padding
				canvasStartX = canvasStartX + yAxisNameObj.width + this.params.yAxisNamePadding;
				canvasWidth = canvasWidth - yAxisNameObj.width - this.params.yAxisNamePadding;
				//Create element for yAxisName - to store width/height
				this.elements.yAxisName = returnDataAsElement (0, 0, yAxisNameObj.width, yAxisNameObj.height);
				this.params.PYAxisNameWidth = yAxisNameObj.width;
			} else
			{
				//If the y-axis name is not to be rotated
				//Calculate the width of the text if in full horizontal mode
				//Create text field to get width
				var yAxisNameObj : Object = createText (true, this.params.PYAxisName, this.tfTestMC, 1, testTFX, testTFY, 0, yAxisNameStyle, false, 0, 0);
				//Get a value for this.params.PYAxisNameWidth
				this.params.PYAxisNameWidth = Number (getFV (this.params.PYAxisNameWidth, yAxisNameObj.width));
				//Get the lesser of the width (to avoid un-necessary space)
				this.params.PYAxisNameWidth = Math.min (this.params.PYAxisNameWidth, yAxisNameObj.width);
				//Accomodate width and padding
				canvasStartX = canvasStartX + this.params.PYAxisNameWidth + this.params.yAxisNamePadding;
				canvasWidth = canvasWidth - this.params.PYAxisNameWidth - this.params.yAxisNamePadding;
				//Create element for yAxisName - to store width/height
				this.elements.yAxisName = returnDataAsElement (0, 0, this.params.PYAxisNameWidth, yAxisNameObj.height);
			}
			delete yAxisNameStyle;
			delete yAxisNameObj;
		}
	
		labelMetrics.updateProp("yAxisNameObj", {yAxisNameWidth: this.params.PYAxisNameWidth, yAxisNamePadding: this.params.yAxisNamePadding});
		
		//Accomodate width for y-axis values. Now, y-axis values conists of two parts
		//(for backward compatibility) - limits (upper and lower) and div line values.
		//So, we'll have to individually run through both of them.
		var yAxisValMaxWidth : Number = 0;
		//Also store the height required to render the text field
		var yAxisValMaxHeight:Number = 0
		var divLineObj : Object;
		var divStyle : Object = this.styleM.getTextStyle (this.objects.YAXISVALUES);
		//Iterate through all the div line values
		for (i = 1; i < this.divLines.length; i ++)
		{
			//If div line value is to be shown
			if (this.divLines [i].showValue)
			{
				//If it's the first or last div Line (limits), and it's to be shown
				if ((i == 1) || (i == this.divLines.length - 1))
				{
					if (this.params.showLimits)
					{
						//Get the width of the text
						divLineObj = createText (true, this.divLines [i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, divStyle, false, 0, 0);
						//Accomodate
						yAxisValMaxWidth = (divLineObj.width > yAxisValMaxWidth) ? (divLineObj.width) : (yAxisValMaxWidth);
						yAxisValMaxHeight = (divLineObj.height > yAxisValMaxHeight) ? (divLineObj.height) : (yAxisValMaxHeight);
					}
				} else 
				{
					//It's a div interval - div line
					//So, check if we've to show div line values
					if (this.params.showDivLineValues)
					{
						//Get the width of the text
						divLineObj = createText (true, this.divLines [i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, divStyle, false, 0, 0);
						//Accomodate
						yAxisValMaxWidth = (divLineObj.width > yAxisValMaxWidth) ? (divLineObj.width) : (yAxisValMaxWidth);
						yAxisValMaxHeight = (divLineObj.height > yAxisValMaxHeight) ? (divLineObj.height) : (yAxisValMaxHeight);
					}
				}
			}
		}
		delete divLineObj;
		//Also iterate through all trend lines whose values are to be shown on
		//left side of the canvas.
		//Get style object
		var trendStyle : Object = this.styleM.getTextStyle (this.objects.TRENDVALUES);
		var trendObj : Object;
		for (i = 1; i <= this.numTrendLines; i ++)
		{
			if (this.trendLines [i].isValid == true && this.trendLines [i].valueOnRight == false)
			{
				//If it's a valid trend line and value is to be shown on left
				//Get the width of the text
				trendObj = createText (true, this.trendLines [i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, trendStyle, false, 0, 0);
				//Accomodate
				yAxisValMaxWidth = (trendObj.width > yAxisValMaxWidth) ? (trendObj.width) : (yAxisValMaxWidth);
			}
		}
		//Accomodate for y-axis/left-trend line values text width
		if (yAxisValMaxWidth > 0)
		{
			canvasStartX = canvasStartX + yAxisValMaxWidth + this.params.yAxisValuesPadding;
			canvasWidth = canvasWidth - yAxisValMaxWidth - this.params.yAxisValuesPadding;
		}
		//Accomodate width for secondary y-axis values. Now, y-axis values conists of two parts
		//(for backward compatibility) - limits (upper and lower) and div line values.
		//So, we'll have to individually run through both of them.
		var SYAxisValMaxWidth : Number = 0;
		var divLineObj : Object;
		var divStyle : Object = this.styleM.getTextStyle (this.objects.YAXISVALUES);
		//Iterate through all the div line values
		for (i = 1; i < this.sDivLines.length; i ++)
		{
			//If div line value is to be shown
			if (this.sDivLines [i].showValue)
			{
				//If it's the first or last div Line (limits), and it's to be shown
				if ((i == 1) || (i == this.sDivLines.length - 1))
				{
					if (this.params.showSecondaryLimits)
					{
						//Get the width of the text
						divLineObj = createText (true, this.sDivLines [i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, divStyle, false, 0, 0);
						//Accomodate
						SYAxisValMaxWidth = (divLineObj.width > SYAxisValMaxWidth) ? (divLineObj.width) : (SYAxisValMaxWidth);
					}
				} else 
				{
					//It's a div interval - div line
					//So, check if we've to show div line values
					if (this.params.showDivLineSecondaryValue)
					{
						//Get the width of the text
						divLineObj = createText (true, this.sDivLines [i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, divStyle, false, 0, 0);
						//Accomodate
						SYAxisValMaxWidth = (divLineObj.width > SYAxisValMaxWidth) ? (divLineObj.width) : (SYAxisValMaxWidth);
					}
				}
			}
		}
		delete divLineObj;
		//Also iterate through all trend lines whose values are to be shown on
		//right side of the canvas.
		//Get style object
		var trendStyle : Object = this.styleM.getTextStyle (this.objects.TRENDVALUES);
		var trendObj : Object;
		for (i = 1; i <= this.numTrendLines; i ++)
		{
			if (this.trendLines [i].isValid == true && this.trendLines [i].valueOnRight == true)
			{
				//If it's a valid trend line and value is to be shown on right
				//Get the width of the text
				trendObj = createText (true, this.trendLines [i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, trendStyle, false, 0, 0);
				//Accomodate
				SYAxisValMaxWidth = (trendObj.width > SYAxisValMaxWidth) ? (trendObj.width) : (SYAxisValMaxWidth);
			}
		}
		//Accomodate for secondary y-axis/right-trend line values text width
		if (SYAxisValMaxWidth > 0)
		{
			canvasWidth = canvasWidth - SYAxisValMaxWidth - this.params.yAxisValuesPadding;
		}
		this.config.rightSideValueWidth = SYAxisValMaxWidth;
		//Now, if secondary y-axis name is to be shown, simulate it and get the width
		if (this.params.SYAxisName != "")
		{
			//Get style object
			var yAxisNameStyle : Object = this.styleM.getTextStyle (this.objects.YAXISNAME);
			if (this.params.rotateYAxisName)
			{
				//Create text field to get width
				var yAxisNameObj : Object = createText (true, this.params.SYAxisName, this.tfTestMC, 1, testTFX, testTFY, 90, yAxisNameStyle, true, this.height-(this.params.chartTopMargin+this.params.chartBottomMargin), canvasWidth/3);
				//Accomodate width and padding
				canvasWidth = canvasWidth - yAxisNameObj.width - this.params.yAxisNamePadding;
				//Create element for yAxisName - to store width/height
				this.elements.SYAxisName = returnDataAsElement (0, 0, yAxisNameObj.width, yAxisNameObj.height);
				this.params.SYAxisNameWidth = yAxisNameObj.width;
			}else
			{
				//If the y-axis name is not to be rotated
				//Calculate the width of the text if in full horizontal mode
				//Create text field to get width
				var yAxisNameObj : Object = createText (true, this.params.SYAxisName, this.tfTestMC, 1, testTFX, testTFY, 0, yAxisNameStyle, false, 0, 0);
				//Get a value for this.params.PYAxisNameWidth
				this.params.SYAxisNameWidth = Number (getFV (this.params.SYAxisNameWidth, yAxisNameObj.width));
				//Get the lesser of the width (to avoid un-necessary space)
				this.params.SYAxisNameWidth = Math.min (this.params.SYAxisNameWidth, yAxisNameObj.width);
				//Accomodate width and padding
				canvasWidth = canvasWidth - this.params.SYAxisNameWidth - this.params.yAxisNamePadding;
				//Create element for yAxisName - to store width/height
				this.elements.SYAxisName = returnDataAsElement (0, 0, this.params.SYAxisNameWidth, yAxisNameObj.height);
			}
			delete yAxisNameStyle;
			delete yAxisNameObj;
		}
		
		labelMetrics.updateProp("yAxisValueObj", {yAxisValMaxWidth: yAxisValMaxWidth, yAxisValuesPadding: this.params.yAxisValuesPadding,
								 yAxisValueAtRight:this.config.rightSideValueWidth});

		labelMetrics.updateProp("sYAxisNameObj", {sYAxisNameWidth: this.params.SYAxisNameWidth, yAxisNamePadding: this.params.yAxisNamePadding});
		
		//Round them off finally to avoid distorted pixels
		canvasStartX = int (canvasStartX);
		canvasWidth = int (canvasWidth);
		//We finally have canvas Width and canvas Start X
		//-----------------------------------------------------------------------------------//
		//Now, we need to calculate the available Height on the canvas.
		//Available height = total Chart height minus the list below
		// - Chart Top and Bottom Margins
		// - Space for Caption, Sub Caption and caption padding
		// - Height of data labels
		// - xAxisName
		//Initialize canvasHeight to total height minus margins
		var canvasHeight : Number = this.height - (this.params.chartTopMargin + this.params.chartBottomMargin);
		//Set canvasStartY
		var canvasStartY : Number = this.params.chartTopMargin;
		//Now, if we've to show caption
		if (this.params.caption != "")
		{
			//Create text field to get height
			var captionObj : Object = createText (true, this.params.caption, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle (this.objects.CAPTION) , true, canvasWidth, canvasHeight/4);
			//Store the height
			canvasStartY = canvasStartY + captionObj.height;
			canvasHeight = canvasHeight - captionObj.height;
			//Create element for caption - to store width & height
			this.elements.caption = returnDataAsElement (0, 0, captionObj.width, captionObj.height);
			delete captionObj;
		}
		//Now, if we've to show sub-caption
		if (this.params.subCaption != "")
		{
			//Create text field to get height
			var subCaptionObj : Object = createText (true, this.params.subCaption, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle (this.objects.SUBCAPTION) , true, canvasWidth, canvasHeight/4);
			//Store the height
			canvasStartY = canvasStartY + subCaptionObj.height;
			canvasHeight = canvasHeight - subCaptionObj.height;
			//Create element for sub caption - to store height
			this.elements.subCaption = returnDataAsElement (0, 0, subCaptionObj.width, subCaptionObj.height);
			delete subCaptionObj;
		}
		//Now, if either caption or sub-caption was shown, we also need to adjust caption padding
		if (this.params.caption != "" || this.params.subCaption != "")
		{
			//Account for padding
			canvasStartY = canvasStartY + this.params.captionPadding;
			canvasHeight = canvasHeight - this.params.captionPadding;
		}
		//-------- Begin: Data Label calculation --------------//
		var labelObj : Object;
		var labelStyleObj : Object = this.styleM.getTextStyle (this.objects.DATALABELS);	
		//Based on label step, set showLabel of each data point as required.
		//Visible label count
		var visibleCount : Number = 0;
		for (i=1; i<=this.num; i++) {
			//Now, the label can be preset to be hidden (set via XML)
			if (this.categories[i].showLabel) {
				visibleCount++;
			}
		}
		//First if the label display is set as Auto, figure the best way 
		//to render them.
		if (this.params.labelDisplay=="AUTO"){
			//Here, we check how many labels are to be shown.
			//Based on that, we decide a fit between WRAP and ROTATE
			//Priority is given to WRAP mode over ROTATE mode
			//WRAP mode is set when at least 5 characters can be shown
			//on the chart, without having to break up into multiple lines.
			//Else, rotate mode is selected.
			//If in rotate mode and a single line cannot be fit, we also 
			//set labelStep, based on available space.
			//Get the width required to plot the characters in wrap mode
			//Storage for string to be simulated.
			var str:String = "";
			//Minimum width required to plot this string in both wrap
			//and rotate mode.
			var wrapMinWidth:Number = 0, rotateMinWidth:Number=0;
			//Build the string by adding upper-case letters A,B,C,D...
			for (i=1; i<=WRAP_MODE_MIN_CHARACTERS; i++){
				//Build the string from upper case A,B,C...
				str = str + String.fromCharCode(64+i);
			}
			//Simulate width of this text field - without wrapping
			labelObj = createText (true, str, this.tfTestMC, 1, testTFX, testTFY, 0, labelStyleObj, false, 0, 0);
			wrapMinWidth = labelObj.width;
			//If we've space to accommodate this width for all labels, render in wrap mode
			if (visibleCount*wrapMinWidth <= canvasWidth){
				//Render all labels in wrap mode
				this.params.labelDisplay="WRAP";
			}else{
				//Since we do not have space to accommodate the width of wrap mode:
				//Render in rotate mode
				this.params.labelDisplay="ROTATE";
				//Figure the minimum width required to display 1 line of text in rotated mode				
				labelObj = createText (true, str, this.tfTestMC, 1, testTFX, testTFY, this.config.labelAngle, labelStyleObj, false, 0, 0);
				//Store the mimimum width required for rotated mode
				rotateMinWidth = labelObj.width;
				//If all the labels cannot be accommodated in minimum width (without getting trimmed),
				//then go for labelStep
				if ((visibleCount/this.params.labelStep)*rotateMinWidth>= canvasWidth){
					//Figure out how many labels we can display
					var numFitLabels:Number = (canvasWidth/rotateMinWidth);
					//Based on how many labels we've to display and how many we can, reset labelStep
					this.params.labelStep = Math.ceil(visibleCount/numFitLabels);					
				}
			}
		}
		//Now, based on user set/auto-calculated label step, set showLabel 
		//of each data point as required.
		//Reset Visible label count
		visibleCount = 0;
		var finalVisibleCount : Number = 0;
		for (i = 1; i <= this.num; i ++)
		{
			//Now, the label can be preset to be hidden (set via XML)
			if (this.categories [i].showLabel)
			{
				visibleCount ++;
				//If label step is defined, we need to set showLabel of those
				//labels which fall on step as false.
				if ((i - 1) % this.params.labelStep == 0)
				{
					this.categories [i].showLabel = true;
				} else 
				{
					this.categories [i].showLabel = false;
				}
			}
			//Update counter
			finalVisibleCount = (this.categories [i].showLabel) ? (finalVisibleCount + 1) : (finalVisibleCount);
		}
		//Store the final visible count
		this.config.finalVisibleCount = finalVisibleCount;
		//now depending on the final showLabel property on fisrt and last label and its display mode
		//we set the first label width property for improve label management. This values will only be used
		//when we go for new label management.
		var maxAllowableLabelHeight:Number = canvasHeight/3;
		if(this.categories [1].showLabel){
			if(this.params.labelDisplay == "ROTATE"){
				labelObj = getTextMetrics(this.categories [1].label, labelStyleObj, maxAllowableLabelHeight);
				labelMetrics.firstLabelWidth = labelObj.textFieldHeight;				
			}else{
				labelObj = getTextMetrics(this.categories [1].label, labelStyleObj);
				labelMetrics.firstLabelWidth = labelObj.textFieldWidth;
			}
		}else{
			labelMetrics.firstLabelWidth = 0;
		}
		if(this.categories [this.num].showLabel){
			if(this.params.labelDisplay == "ROTATE"){
				labelObj = getTextMetrics(this.categories [this.num].label, labelStyleObj, maxAllowableLabelHeight);
				labelMetrics.lastLabelWidth = labelObj.textFieldHeight;				
			}else{
				labelObj = getTextMetrics(this.categories [this.num].label, labelStyleObj);
				labelMetrics.lastLabelWidth = labelObj.textFieldWidth;
			}
		}else{
			labelMetrics.lastLabelWidth = 0;
		}
		labelObj = null;
		//Data labels can be rendered in 3 ways:
		//1. Normal - no staggering - no wrapping - no rotation
		//2. Wrapped - no staggering - no rotation
		//3. Staggered - no wrapping - no rotation
		//4. Rotated - no staggering - no wrapping
		//Placeholder to store max height
		this.config.maxLabelHeight = 0;
		this.config.labelAreaHeight = 0;
		if (this.params.labelDisplay == "ROTATE")
		{
			//Calculate the maximum width that could be alloted to the labels.
			//Note: Here, width is calculated based on canvas height, as the labels
			//are going to be rotated.
			var maxLabelWidth : Number = (canvasHeight / 3);
			var maxLabelHeight : Number = (canvasWidth / finalVisibleCount);
			//Store it in config for later usage
			this.config.wrapLabelWidth = maxLabelWidth;
			this.config.wrapLabelHeight = maxLabelHeight;
			//Case 4: If the labels are rotated, we iterate through all the string labels
			//provided to us and get the height and store max.
			for (i = 1; i <= this.num; i ++)
			{
				//If the label is to be shown
				if (this.categories [i].showLabel)
				{
					//Create text box and get height
					labelObj = createText (true, this.categories [i].label, this.tfTestMC, 1, testTFX, testTFY, this.config.labelAngle, labelStyleObj, true, maxLabelWidth, maxLabelHeight);
					//Store the larger
					this.config.maxLabelHeight = (labelObj.height > this.config.maxLabelHeight) ? (labelObj.height) : (this.config.maxLabelHeight);
				}
			}
			//for slanted labels the maxLabelHeight may exceed the limit defined for the height. 
			//we take the mimimum of two
			//Store max label height as label area height.
			this.config.labelAreaHeight = Math.min(maxLabelWidth, this.config.maxLabelHeight);
		} else if (this.params.labelDisplay == "WRAP")
		{
			//Case 2 (WRAP): Create all the labels on the chart. Set width as
			//totalAvailableWidth/finalVisibleCount.
			//Set max height as 50% of available canvas height at this point of time. Find all
			//and select the max one.
			var maxLabelWidth : Number = (canvasWidth / finalVisibleCount);
			var maxLabelHeight : Number = (canvasHeight / 3);
			//Store it in config for later usage
			this.config.wrapLabelWidth = maxLabelWidth;
			this.config.wrapLabelHeight = maxLabelHeight;
			for (i = 1; i <= this.num; i ++)
			{
				//If the label is to be shown
				if (this.categories [i].showLabel)
				{
					//Create text box and get height
					labelObj = createText (true, this.categories [i].label, this.tfTestMC, 1, testTFX, testTFY, 0, labelStyleObj, true, maxLabelWidth, maxLabelHeight);
					//Store the larger
					this.config.maxLabelHeight = (labelObj.height > this.config.maxLabelHeight) ? (labelObj.height) : (this.config.maxLabelHeight);
				}
			}
			//Store max label height as label area height.
			this.config.labelAreaHeight = this.config.maxLabelHeight;
		} else 
		{
			//Case 1,3: Normal or Staggered Label
			//We iterate through all the labels, and if any of them has &lt or < (HTML marker)
			//embedded in them, we add them to the array, as for them, we'll need to individually
			//create and see the text height. Also, the first element in the array - we set as
			//ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_=....
			//Create array to store labels.
			var strLabels : Array = new Array ();
			strLabels.push ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890_=/*-+~`");
			//Now, iterate through all the labels and for those visible labels, whcih have < sign,
			//add it to array.
			for (i = 1; i <= this.num; i ++)
			{
				//If the label is to be shown
				if (this.categories [i].showLabel)
				{
					if ((this.categories [i].label.indexOf ("&lt;") > - 1) || (this.categories [i].label.indexOf ("<") > - 1))
					{
						strLabels.push (this.categories [i].label);
					}
				}
			}
			//Now, we've the array for which we've to check height (for each element).
			for (i = 0; i < strLabels.length; i ++)
			{
				//Create text box and get height
				labelObj = createText (true, this.categories [i].label, this.tfTestMC, 1, testTFX, testTFY, 0, labelStyleObj, false, 0, 0);
				//Store the larger
				this.config.maxLabelHeight = (labelObj.height > this.config.maxLabelHeight) ? (labelObj.height) : (this.config.maxLabelHeight);
			}
			//We now have the max label height. If it's staggered, then store accordingly, else
			//simple mode
			if (this.params.labelDisplay == "STAGGER")
			{
				//Here we again validate the stagger lines. The minimum is validated at the time of parsing
				//the maximum is validated here.
				if(this.params.staggerLines > this.num){
					this.params.staggerLines = this.num;
				}
				//Multiply max label height by stagger lines.
				this.config.labelAreaHeight = this.params.staggerLines * this.config.maxLabelHeight;
			} else 
			{
				this.config.labelAreaHeight = this.config.maxLabelHeight;
			}
		}
		if (this.config.labelAreaHeight > 0)
		{
			//Deduct the calculated label height from canvas height
			canvasHeight = canvasHeight - this.config.labelAreaHeight - this.params.labelPadding;
		}
		//Delete objects
		delete labelObj;
		delete labelStyleObj;
		//Accomodate space for xAxisName (if to be shown);
		if (this.params.xAxisName != "")
		{
			//Create text field to get height
			var xAxisNameObj : Object = createText (true, this.params.xAxisName, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle (this.objects.XAXISNAME) , true, canvasWidth, canvasHeight/2);
			//Store the height
			canvasHeight = canvasHeight - xAxisNameObj.height - this.params.xAxisNamePadding;
			//Object to store width and height of xAxisName
			this.elements.xAxisName = returnDataAsElement (0, 0, xAxisNameObj.width, xAxisNameObj.height);
			delete xAxisNameObj;
		}
		//----------- HANDLING CUSTOM CANVAS MARGINS --------------//
		//Before doing so, we take into consideration, user's forced canvas margins (if any defined)
		//If the user's forced values result in overlapping of chart items, we ignore.
		if (this.params.canvasLeftMargin!=-1 && this.params.canvasLeftMargin>canvasStartX){
			//Update width (deduct the difference)
			canvasWidth = canvasWidth - (this.params.canvasLeftMargin-canvasStartX);
			//Update left start position
			canvasStartX = this.params.canvasLeftMargin;		
			//valid left margin is defined
			this.validCanvasLeftMargin = true;
		}
		if (this.params.canvasRightMargin!=-1 && (this.params.canvasRightMargin>(this.width - (canvasStartX+canvasWidth)))){
			//Update width (deduct the difference)
			canvasWidth = canvasWidth - (this.params.canvasRightMargin-(this.width - (canvasStartX+canvasWidth)));			
			//valid right margin is defined
			this.validCanvasRightMargin = true;
		}
		if (this.params.canvasTopMargin!=-1 && this.params.canvasTopMargin>canvasStartY){
			//Update height (deduct the difference)
			canvasHeight = canvasHeight - (this.params.canvasTopMargin-canvasStartY);
			//Update top start position
			canvasStartY = this.params.canvasTopMargin;		
		}
		if (this.params.canvasBottomMargin!=-1 && (this.params.canvasBottomMargin>(this.height - (canvasStartY+canvasHeight)))){
			//Update height(deduct the difference)
			canvasHeight = canvasHeight - (this.params.canvasBottomMargin-(this.height - (canvasStartY+canvasHeight)));
		}
		
		labelMetrics.updateProp("canvasMarginObj", {canvasLeftMargin: this.params.canvasLeftMargin, canvasRightMargin: this.params.canvasRightMargin,
													validCanvasLeftMargin:this.validCanvasLeftMargin, validCanvasRightMargin:this.validCanvasRightMargin});
		
		//------------ END OF CUSTOM CANVAS MARGIN HANDLING --------------------//
		//Based on canvas height that has been calculated, re-adjust yaxisLabelStep
		this.adjustYAxisLabelStep(yAxisValMaxHeight, canvasHeight);
		//Create an element to represent the canvas now.
		this.elements.canvas = returnDataAsElement (canvasStartX, canvasStartY, canvasWidth, canvasHeight);
		//Base Plane position - Base plane is the y-plane from which columns start.
		//If there's a 0 value in between yMin,yMax, base plane represents 0 value.
		//Else, it's yMin
		if (this.config.PYMax >= 0 && this.config.PYMin < 0)
		{
			//Negative and positive numbers present - so set basePlanePos as 0 value
			this.config.pBasePlanePos = this.getAxisPosition (0, this.config.PYMax, this.config.PYMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
		} else if (this.config.PYMax < 0 && this.config.PYMin < 0)
		{
			//Both yMin and yMax are negative - so columns emanate from max
			this.config.pBasePlanePos = this.getAxisPosition (this.config.PYMax, this.config.PYMax, this.config.PYMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
		}else
		{
			//No negative numbers - so set basePlanePos as yMin value
			this.config.pBasePlanePos = this.getAxisPosition (this.config.PYMin, this.config.PYMax, this.config.PYMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
		}
		//Get base plane position if columns are present in SECONDARY AXIS too
		if (this.config.SYMax >= 0 && this.config.SYMin < 0)
		{
			//Negative and positive numbers present - so set basePlanePos as 0 value
			this.config.sBasePlanePos = this.getAxisPosition (0, this.config.SYMax, this.config.SYMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
		} else if (this.config.SYMax < 0 && this.config.SYMin < 0)
		{
			//Both yMin and yMax are negative - so columns emanate from max
			this.config.sBasePlanePos = this.getAxisPosition (this.config.SYMax, this.config.SYMax, this.config.SYMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
		}else
		{
			//No negative numbers - so set basePlanePos as yMin value
			this.config.sBasePlanePos = this.getAxisPosition (this.config.SYMin, this.config.SYMax, this.config.SYMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
		}
		//Y Max, Y Min Pos, base Plane Position (Dependent on parentYAxis)
		var yMin : Number, yMax : Number, basePlanePos : Number;
		//Now, if we've any columns on the chart, then the x-position of category names,
		//lines and areas would be dependent on x of column. Else, they would be equally
		//distributed over x of canvas (considering canvasPadding)
		if (this.numColDS > 0)
		{
			//Now, calculate the spacing on canvas and individual column width
			var plotSpace : Number = (this.params.plotSpacePercent / 100) * this.elements.canvas.w;
			//Block Width
			var blockWidth : Number = (this.elements.canvas.w - plotSpace) / this.num;
			//Individual column space.
			var columnWidth : Number = blockWidth / this.numColDS;
			//Max column width can be 50 - so if exceeded, reset width and space
			//Now, there can be an exception if this.params.plotSpacePercent has
			//been defined
			if (columnWidth > 50 && this.defaultPlotSpacePercent)
			{
				columnWidth = 50;
				blockWidth = columnWidth * this.numColDS;
				plotSpace = this.elements.canvas.w - (this.num * blockWidth);
				this.params.plotSpacePercent = (plotSpace * 100) / canvasWidth;
			}
			//We finally have total plot space and column width
			//Store it in config
			this.config.plotSpace = plotSpace;
			this.config.blockWidth = blockWidth;
			this.config.columnWidth = columnWidth;
			//Get space between two blocks
			var interBlockSpace : Number = plotSpace / (this.num + 1);
			//Store in config.
			this.config.interBlockSpace = interBlockSpace;
			
			labelMetrics.canvasPadding = this.config.interBlockSpace + (this.config.blockWidth / 2);
			
			//now calculate the panels
			//check if new label management is required
			if(this.params.XTLabelManagement){
				labelMetrics.calculatePanels();
				//now we should go for final label management calculation
				var metricsObj:Object = labelMetrics.getChartMetrics( this.num, labelMetrics.totalWorkingObj.totalWorkingWidth, 
													  labelMetrics.leftPanelObj.leftPanelMinWidth, labelMetrics.rightPanelObj.rightPanelMinWidth, 
													  labelMetrics.firstLabelWidth, labelMetrics.lastLabelWidth,
													  labelMetrics.changeCanvasPadding);
				//store globally.
				this.config.labelMetricsObj = metricsObj;
				//based on the new interplot width and panel we need to recalculate the interPlotSpace
				//and column width - Following are derived formulas by numeric analysis.
				var plotSpaceRatio:Number = (this.num * this.params.plotSpacePercent / 100) / (this.num - this.params.plotSpacePercent / 100 + 1);
				var newColumnWidth:Number = ( (1 - plotSpaceRatio) / (this.num - 1) * metricsObj.totalInterPlotWidth);
				var newSpaceWidth:Number = ( plotSpaceRatio / (this.num - 1) * metricsObj.totalInterPlotWidth);
				var newCanvasWidth:Number = ( (this.num + plotSpaceRatio) / (this.num - 1) * metricsObj.totalInterPlotWidth);
				//as the new canvas width is always les than the initial
				var amountOfDiff:Number = canvasWidth - newCanvasWidth;
				
			}
			
			var dataEndY : Number;
			//Now, store the positions of the columns
			for (i = 1; i <= this.num; i ++)
			{
				//Store position of categories
				if(this.params.XTLabelManagement){
					this.categories [i].x = this.elements.canvas.x + (amountOfDiff/2) + (newSpaceWidth * i) + newColumnWidth  * (i - 0.5);
				}else{
					this.categories [i].x = this.elements.canvas.x + (interBlockSpace * i) + columnWidth * this.numColDS * (i - 0.5);
				}
				var colCounter : Number = 0;
				for (j = 1; j <= this.numDS; j ++)
				{
					//Get parentYAxis dependent Base plane position
					if (this.dataset [j].parentYAxis == "P")
					{
						basePlanePos = this.config.pBasePlanePos;
					}else
					{
						basePlanePos = this.config.sBasePlanePos;
					}
					//If it's column dataset
					if (this.dataset [j].renderAs == "COLUMN")
					{
						//Increment column counter
						colCounter ++;
						//X-Position
						this.dataset [j].data [i].x = this.elements.canvas.x + (interBlockSpace * i) + columnWidth * (colCounter - 0.5) + (columnWidth * this.numColDS * (i - 1));
						//Set the y position
						this.dataset [j].data [i].y = basePlanePos;
						//Height for each column
						dataEndY = this.getAxisPosition (this.dataset [j].data [i].value, (this.dataset [j].parentYAxis == "P") ?this.config.PYMax : this.config.SYMax, (this.dataset [j].parentYAxis == "P") ?this.config.PYMin : this.config.SYMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
						//Negate to cancel Flash's reverse Y Co-ordinate system
						this.dataset [j].data [i].h = - (dataEndY - basePlanePos);
						//Width - Deduct 1 from width to allot some space between two columns
						this.dataset [j].data [i].w = (this.params.showShadow && columnWidth > 2) ? (columnWidth - 1) : columnWidth;
						//Store value textbox y position
						this.dataset [j].data [i].valTBY = dataEndY;
					}
				}
			}
			//Now, based on column x position, calculate line and area positions
			//Store y-max and y-min positions for data
			this.config.PYMaxPos = 0;
			this.config.PYMinPos = 0;
			//Now, store the positions of the lines/areas
			for (i = 1; i <= this.numDS; i ++)
			{
				//Store dataset specific yMax and yMin
				yMax = (this.dataset [i].parentYAxis == "P") ?this.config.PYMax : this.config.SYMax;
				yMin = (this.dataset [i].parentYAxis == "P") ?this.config.PYMin : this.config.SYMin;
				if (this.dataset [i].renderAs != "COLUMN")
				{
					for (j = 1; j <= this.num; j ++)
					{
						//X-Position
						this.dataset [i].data [j].x = this.categories [j].x;
						//Set the y position
						this.dataset [i].data [j].y = this.getAxisPosition (this.dataset [i].data [j].value, yMax, yMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
						//Store max and min positions for use in animation position - if area dataset
						if (this.dataset [i].renderAs == "AREA")
						{
							this.config.PYMaxPos = (this.dataset [i].data [j].y > this.config.PYMaxPos) ? this.dataset [i].data [j].y : this.config.PYMaxPos;
							this.config.PYMinPos = (this.dataset [i].data [j].y < this.config.PYMinPos) ? this.dataset [i].data [j].y : this.config.PYMinPos;
						}
						//Store value textbox y position
						this.dataset [i].data [j].valTBY = this.dataset [i].data [j].y;
					}
				}
			}
		}
		else
		{
			//Completely different set of calculation - just for area and line
			//We now need to calculate the position of area points on the chart.
			//Now, calculate the width between two points on chart
			var interPointWidth : Number = (this.elements.canvas.w - (2 * this.params.canvasPadding)) / (this.num - 1);
			//Store y-max and y-min positions for data
			this.config.PYMaxPos = 0;
			this.config.PYMinPos = 0;
			//Now, store the positions of the columns
			for (i = 1; i <= this.numDS; i ++)
			{
				//Store dataset specific yMax and yMin
				yMax = (this.dataset [i].parentYAxis == "P") ?this.config.PYMax : this.config.SYMax;
				yMin = (this.dataset [i].parentYAxis == "P") ?this.config.PYMin : this.config.SYMin;
				for (j = 1; j <= this.num; j ++)
				{
					//X-Position
					//Now, if there is only 1 point on the chart, we center it. Else, we get even X.
					this.dataset [i].data [j].x = (this.num == 1) ? (this.elements.canvas.x + this.elements.canvas.w / 2) : (this.elements.canvas.x + this.params.canvasPadding + (interPointWidth * (j - 1)));
					if (i == 1)
					{
						this.categories [j].x = this.dataset [i].data [j].x;
					}
					//Set the y position
					this.dataset [i].data [j].y = this.getAxisPosition (this.dataset [i].data [j].value, yMax, yMin, this.elements.canvas.y, this.elements.canvas.toY, true, 0);
					//Store max and min positions for use in animation position - if area dataset
					if (this.dataset [i].renderAs == "AREA")
					{
						this.config.PYMaxPos = (this.dataset [i].data [j].y > this.config.PYMaxPos) ? this.dataset [i].data [j].y : this.config.PYMaxPos;
						this.config.PYMinPos = (this.dataset [i].data [j].y < this.config.PYMinPos) ? this.dataset [i].data [j].y : this.config.PYMinPos;
					}
					//Store value textbox y position
					this.dataset [i].data [j].valTBY = this.dataset [i].data [j].y;
				}
			}
		}
	}
	/**
	* allotDepths method allots the depths for various chart objects
	* to be rendered. We do this before hand, so that we can later just
	* go on rendering chart objects, without swapping.
	*/
	private function allotDepths () : Void
	{
		//Background
		this.dm.reserveDepths ("BACKGROUND", 1);
		//Click URL Handler
		this.dm.reserveDepths ("CLICKURLHANDLER", 1);
		//Background SWF
		this.dm.reserveDepths ("BGSWF", 1);
		//Canvas
		this.dm.reserveDepths ("CANVAS", 1);
		//If horizontal grid is to be shown
		if (this.params.showAlternateHGridColor)
		{
			this.dm.reserveDepths ("HGRID", Math.ceil ((this.divLines.length + 1) / 2));
		}
		//Div Lines and their labels
		this.dm.reserveDepths ("DIVLINES", (this.divLines.length * 3));
		//Caption
		this.dm.reserveDepths ("CAPTION", 1);
		//Sub-caption
		this.dm.reserveDepths ("SUBCAPTION", 1);
		//X-Axis Name
		this.dm.reserveDepths ("XAXISNAME", 1);
		//Y-Axis Name - Primary and Secondary
		this.dm.reserveDepths ("YAXISNAME", 2);
		//Trend lines below plot (lines and their labels)
		this.dm.reserveDepths ("TRENDLINESBELOW", this.numTrendLinesBelow);
		this.dm.reserveDepths ("TRENDVALUESBELOW", this.numTrendLinesBelow);
		//Vertical div lines
		this.dm.reserveDepths ("VLINES", this.numVLines);
		//Vertical div lines labels
		this.dm.reserveDepths ("VLINELABELS", this.numVLines);
		//Vertical div lines labels
		this.dm.reserveDepths ("VLINELABELS", this.numVLines);
		//Data Labels
		this.dm.reserveDepths ("DATALABELS", this.num);
		//Data Columns
		this.dm.reserveDepths ("DATAPLOTCOLUMN", this.numColDS * this.num);
		//Line Plot
		this.dm.reserveDepths ("DATAPLOTLINE", this.numLineDS);
		//Zero Plane
		this.dm.reserveDepths ("ZEROPLANE", 2);
		//Anchors
		this.dm.reserveDepths ("ANCHORS", this.num);
		//Trend lines below plot (lines and their labels)
		this.dm.reserveDepths ("TRENDLINESABOVE", (this.numTrendLines - this.numTrendLinesBelow));
		this.dm.reserveDepths ("TRENDVALUESABOVE", (this.numTrendLines - this.numTrendLinesBelow));
		//Canvas Border
		this.dm.reserveDepths ("CANVASBORDER", 1);
		//Data Values
		this.dm.reserveDepths ("DATAVALUESCOLUMN", this.num * this.numColDS);
		this.dm.reserveDepths ("DATAVALUESLINE", this.num * this.numLineDS);
	}
	//--------------- VISUAL RENDERING METHODS -------------------------//
	/**
	* drawHeaders method renders the following on the chart:
	* CAPTION, SUBCAPTION, XAXISNAME, YAXISNAME
	*/
	private function drawHeaders ()
	{
		//Render caption
		if (this.params.caption != "")
		{
			var captionStyleObj : Object = this.styleM.getTextStyle (this.objects.CAPTION);
			captionStyleObj.vAlign = "bottom";
			//Switch the alignment to lower case
			captionStyleObj.align = captionStyleObj.align.toLowerCase();
			//Now, based on alignment, decide the xPosition of the caption
			var xPos:Number = (captionStyleObj.align=="center")?(this.elements.canvas.x + (this.elements.canvas.w / 2)):((captionStyleObj.align=="left")?(this.elements.canvas.x):(this.elements.canvas.toX));
			var captionObj : Object = createText (false, this.params.caption, this.cMC, this.dm.getDepth ("CAPTION") , xPos , this.params.chartTopMargin, 0, captionStyleObj, true, this.elements.caption.w, this.elements.caption.h);
			//Apply animation
			if (this.params.animation)
			{
				this.styleM.applyAnimation (captionObj.tf, this.objects.CAPTION, this.macro, captionObj.tf._x , 0, captionObj.tf._y , 0, 100, null, null, null);
			}
			//Apply filters
			this.styleM.applyFilters (captionObj.tf, this.objects.CAPTION);
			//Delete
			delete captionObj;
			delete captionStyleObj;
		}
		//Render sub caption
		if (this.params.subCaption != "")
		{
			var subCaptionStyleObj : Object = this.styleM.getTextStyle (this.objects.SUBCAPTION);
			subCaptionStyleObj.vAlign = "top";
			//Switch the alignment to lower case
			subCaptionStyleObj.align = subCaptionStyleObj.align.toLowerCase();
			//Now, based on alignment, decide the xPosition of the caption
			var xPos:Number = (subCaptionStyleObj.align=="center")?(this.elements.canvas.x + (this.elements.canvas.w / 2)):((subCaptionStyleObj.align=="left")?(this.elements.canvas.x):(this.elements.canvas.toX));
			var subCaptionObj : Object = createText (false, this.params.subCaption, this.cMC, this.dm.getDepth ("SUBCAPTION") , xPos , this.elements.canvas.y - this.params.captionPadding, 0, subCaptionStyleObj, true, this.elements.subCaption.w, this.elements.subCaption.h);
			//Apply animation
			if (this.params.animation)
			{
				this.styleM.applyAnimation (subCaptionObj.tf, this.objects.SUBCAPTION, this.macro, subCaptionObj.tf._x , 0, subCaptionObj.tf._y, 0, 100, null, null, null);
			}
			//Apply filters
			this.styleM.applyFilters (subCaptionObj.tf, this.objects.SUBCAPTION);
			//Delete
			delete subCaptionObj;
			delete subCaptionStyleObj;
		}
		//Render x-axis name
		if (this.params.xAxisName != "")
		{
			var xAxisNameStyleObj : Object = this.styleM.getTextStyle (this.objects.XAXISNAME);
			xAxisNameStyleObj.align = "center";
			xAxisNameStyleObj.vAlign = "bottom";
			var xAxisNameObj : Object = createText (false, this.params.xAxisName, this.cMC, this.dm.getDepth ("XAXISNAME") , this.elements.canvas.x + (this.elements.canvas.w / 2) , this.height -(this.params.chartBottomMargin + this.elements.xAxisName.h + this.params.xAxisNamePadding), 0, xAxisNameStyleObj, true, this.elements.xAxisName.w, this.elements.xAxisName.h);
			//Apply animation
			if (this.params.animation)
			{
				this.styleM.applyAnimation (xAxisNameObj.tf, this.objects.XAXISNAME, this.macro, this.elements.canvas.x + (this.elements.canvas.w / 2) - (this.elements.subCaption.w / 2) , 0, this.height -(this.params.chartBottomMargin + this.elements.xAxisName.h + this.params.xAxisNamePadding), 0, 100, null, null, null);
			}
			//Apply filters
			this.styleM.applyFilters (xAxisNameObj.tf, this.objects.XAXISNAME);
			//Delete
			delete xAxisNameObj;
			delete xAxisNameStyleObj;
		}
		//Render primary y-axis name
		if (this.params.PYAxisName != "")
		{
			var yAxisNameStyleObj : Object = this.styleM.getTextStyle (this.objects.YAXISNAME);
			//Set alignment parameters
			yAxisNameStyleObj.align = "left";
			yAxisNameStyleObj.vAlign = "middle";
			//If the name is to be rotated
			if (this.params.rotateYAxisName)
			{
				if(this.params.centerYAxisName){
					//Center primary y axis name with respect to chart.
					var yAxisNameObj : Object = createText(false, this.params.PYAxisName, this.cMC, this.dm.getDepth("YAXISNAME"), this.params.chartLeftMargin, this.height/2, 270, yAxisNameStyleObj, true, this.elements.yAxisName.h, this.elements.yAxisName.w);
				} else {
					//Center primary y axis name with respect to canvas.
					var yAxisNameObj : Object = createText (false, this.params.PYAxisName, this.cMC, this.dm.getDepth ("YAXISNAME") , this.params.chartLeftMargin, this.elements.canvas.y + (this.elements.canvas.h / 2), 270, yAxisNameStyleObj, true, this.elements.yAxisName.h, this.elements.yAxisName.w);
				}
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (yAxisNameObj.tf, this.objects.YAXISNAME, this.macro, yAxisNameObj.tf._x, 0, yAxisNameObj.tf._y, 0, 100, null, null, null);
				}
			}else
			{
				//We show horizontal name
				//Adding 1 to this.params.PYAxisNameWidth and then passing to avoid line breaks
				var yAxisNameObj : Object = createText (false, this.params.PYAxisName, this.cMC, this.dm.getDepth ("YAXISNAME") , this.params.chartLeftMargin, this.elements.canvas.y + (this.elements.canvas.h / 2) , 0, yAxisNameStyleObj, true, this.params.PYAxisNameWidth + 1, this.elements.canvas.h);
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (yAxisNameObj.tf, this.objects.YAXISNAME, this.macro, this.params.chartLeftMargin, 0, yAxisNameObj.tf._y, 0, 100, null, null, null);
				}
			}
			//Apply filters
			this.styleM.applyFilters (yAxisNameObj.tf, this.objects.YAXISNAME);
			//Delete
			delete yAxisNameObj;
			delete yAxisNameStyleObj;
		}
		//Render secondary y-axis name
		if (this.params.SYAxisName != "")
		{
			var yAxisNameStyleObj : Object = this.styleM.getTextStyle (this.objects.YAXISNAME);
			//Set alignment parameters
			yAxisNameStyleObj.align = "left";
			yAxisNameStyleObj.vAlign = "middle";
			//If the name is to be rotated
			if (this.params.rotateYAxisName)
			{
				if(this.params.centerYAxisName){
					//Center secondary y axis name with respect to chart.
					var yAxisNameObj : Object = createText(false, this.params.SYAxisName, this.cMC, this.dm.getDepth("YAXISNAME") + 1, this.elements.canvas.toX + this.params.yAxisValuesPadding + this.config.rightSideValueWidth + this.params.yAxisNamePadding, this.height/2, 270, yAxisNameStyleObj, true, this.elements.SYAxisName.h, this.elements.SYAxisName.w);
				} else {
					//Center secondary y axis name with respect to canvas.
					var yAxisNameObj : Object = createText (false, this.params.SYAxisName, this.cMC, this.dm.getDepth ("YAXISNAME") + 1, this.elements.canvas.toX + this.params.yAxisValuesPadding + this.config.rightSideValueWidth + this.params.yAxisNamePadding, this.elements.canvas.y + (this.elements.canvas.h / 2), 270, yAxisNameStyleObj, true, this.elements.SYAxisName.h, this.elements.SYAxisName.w);
				}
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (yAxisNameObj.tf, this.objects.YAXISNAME, this.macro, this.elements.canvas.toX + this.params.yAxisValuesPadding + this.config.rightSideValueWidth + this.params.yAxisNamePadding, 0, this.elements.canvas.y + (this.elements.canvas.h / 2) + (this.elements.yAxisName.h / 2) , 0, 100, null, null, null);
				}
			}else
			{
				//We show horizontal name
				//Adding 1 to this.params.PYAxisNameWidth and then passing to avoid line breaks
				var yAxisNameObj : Object = createText (false, this.params.SYAxisName, this.cMC, this.dm.getDepth ("YAXISNAME") + 1, this.elements.canvas.toX + this.params.yAxisValuesPadding + this.config.rightSideValueWidth + this.params.yAxisNamePadding, this.elements.canvas.y + (this.elements.canvas.h / 2) , 0, yAxisNameStyleObj, true, this.params.SYAxisNameWidth + 1, this.elements.canvas.h);
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (yAxisNameObj.tf, this.objects.YAXISNAME, this.macro, this.elements.canvas.toX + this.params.yAxisValuesPadding + this.config.rightSideValueWidth + this.params.yAxisNamePadding, 0, yAxisNameObj.tf._y, 0, 100, null, null, null);
				}
			}
			//Apply filters
			this.styleM.applyFilters (yAxisNameObj.tf, this.objects.YAXISNAME);
			//Delete
			delete yAxisNameObj;
			delete yAxisNameStyleObj;
		}
		//Clear Interval
		clearInterval (this.config.intervals.headers);
	}
	/**
	* drawLabels method draws labels with new label management or with the previous label management
	**/
	private function drawLabels()
	{
		if(this.params.XTLabelManagement){
			drawExtremeLabels();
		}else{
			drawNormalLabels()
		}
		//Clear interval
		clearInterval (this.config.intervals.labels);
	}
	/**
	 *
	 */
	 private function drawExtremeLabels()
	 {
		var labelRenderer:LabelRenderer = new LabelRenderer();
		var labelStyleObj : Object = this.styleM.getTextStyle (this.objects.DATALABELS);
		var depth : Number = this.dm.getDepth ("DATALABELS");
		var styleManager:Object = this.styleM;
		var macroRef:Object = this.macro;
		var objId:Number = this.objects.DATALABELS;
		labelRenderer.dummyMC = this.tfTestMC;
		labelRenderer.testXPos = testTFX;
		labelRenderer.testYPos = testTFY;
		labelRenderer.renderXAxisLabels(this.cMC, depth, this.num, this.categories, labelStyleObj, this.config, this.params.labelDisplay,
										this.elements.canvas, this.params.labelPadding, this.params.staggerLines, this.params.labelStep,
										this.params.animation,
										styleManager, macroRef, objId,
										this.params.showExtremeLabelRegion)
	 }
	/**
	* drawNormalLabels method draws the x-axis labels based on the parameters. and with the old algorithm.
	*/
	private function drawNormalLabels ()
	{
		var labelObj : Object;
		var labelStyleObj : Object = this.styleM.getTextStyle (this.objects.DATALABELS);
		var labelYShift : Number;
		var staggerCycle : Number = 0;
		var staggerAddFn : Number = 1;
		var depth : Number = this.dm.getDepth ("DATALABELS");
		var i : Number;
		var count:Number = 0;
		for (i = 1; i <= this.num; i ++)
		{
			//If the label is to be shown
			if (this.categories [i].showLabel)
			{
				if (this.params.labelDisplay == "ROTATE")
				{
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					//Create text box and get height
					labelObj = createText (false, this.categories [i].label, this.cMC, depth, this.categories [i].x, this.elements.canvas.toY + this.params.labelPadding, this.config.labelAngle, labelStyleObj, true, this.config.wrapLabelWidth, this.config.wrapLabelHeight);
				} else if (this.params.labelDisplay == "WRAP")
				{
					//Case 2 (WRAP)
					//Set alignment
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					labelObj = createText (false, this.categories [i].label, this.cMC, depth, this.categories [i].x, this.elements.canvas.toY + this.params.labelPadding, 0, labelStyleObj, true, this.config.wrapLabelWidth, this.config.wrapLabelHeight);
				} else if (this.params.labelDisplay == "STAGGER")
				{
					//Case 3 (Stagger)
					//Set alignment
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					//Need to get cyclic position for staggered textboxes
					//Matrix formed is of 2*this.params.staggerLines - 2 rows
					count++;
					var pos : Number = count % (2 * this.params.staggerLines - 2);
					//Last element needs to be reset
					pos = (pos == 0 || isNaN(pos) ) ? (2 * this.params.staggerLines - 2) : pos;
					//Cyclic iteration
					pos = (pos > this.params.staggerLines) ? (this.params.staggerLines - (pos % this.params.staggerLines)) : pos;
					//Get position to 0 base
					pos --;
					//Shift accordingly
					var labelYShift : Number = this.config.maxLabelHeight * ((pos < 0)? 0 : pos);
					labelObj = createText (false, this.categories [i].label, this.cMC, depth, this.categories [i].x, this.elements.canvas.toY + this.params.labelPadding + labelYShift, 0, labelStyleObj, false, 0, 0);
				} else 
				{
					//Render normal label
					labelStyleObj.align = "center";
					labelStyleObj.vAlign = "bottom";
					labelObj = createText (false, this.categories [i].label, this.cMC, depth, this.categories [i].x, this.elements.canvas.toY + this.params.labelPadding, 0, labelStyleObj, false, 0, 0);
				}
				//Apply filter
				this.styleM.applyFilters (labelObj.tf, this.objects.DATALABELS);
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (labelObj.tf, this.objects.DATALABELS, this.macro, labelObj.tf._x, 0, labelObj.tf._y, 0, 100, null, null, null);
				}
				//Increase depth
				depth ++;
			}
		}
		//Clear interval
		clearInterval (this.config.intervals.labels);
	}
	/**
	* drawColumns method draws the columns on the chart
	*/
	private function drawColumns ()
	{
		//Variables
		var colMC : MovieClip;		
		var depth : Number = this.dm.getDepth ("DATAPLOTCOLUMN");
		var i : Number, j : Number;
		//Create arrays for gradient (if plot gradient color is defined)
		var ratios : Array = new Array ();
		var alphas : Array = new Array ();
		var colors : Array = new Array ();
		if (this.params.plotGradientColor != "")
		{
			//Gradient Fill
			ratios = [0, 255];
			alphas = [100, 100];
		}
		else
		{
			//Solid fill
			ratios = [255];
			alphas = [100];
		}
		this.dataset [i].data [j].color, this.dataset [i].data [j].alpha, this.dataset [i].data [j].ratio
		//Create function storage containers for Delegate functions
		var fnRollOver : Function, fnClick : Function;
		//Iterate through all columns
		for (i = 1; i <= this.numDS; i ++)
		{
			//If it's column data set
			if (this.dataset [i].renderAs == "COLUMN")
			{
				for (j = 1; j <= this.num; j ++)
				{
					//If defined
					if (this.dataset [i].data [j].isDefined)
					{
						//Create an empty movie clip for this column
						colMC = this.cMC.createEmptyMovieClip ("Column_" + i + "_" + j, depth);
						//Register with object Manager
						objM.register(colMC, "DATAPLOT_" + i + "_" + j, "DATAPLOTS_"+i)
						//Create colors array
						if (this.params.plotGradientColor != "")
						{
							colors = [parseInt (this.dataset [i].data [j].color, 16) , parseInt (this.params.plotGradientColor, 16)];
						}else
						{
							colors = [parseInt (this.dataset [i].data [j].color, 16)];
						}
						if (this.params.useRoundEdges){
							var colIns:RoundColumn2D = new RoundColumn2D(colMC, this.dataset [i].data [j].w-1, this.dataset [i].data [j].h, this.roundEdgeRadius, this.dataset [i].data [j].color, this.dataset [i].plotBorderThickness, this.dataset [i].plotBorderAlpha);
						}else{				
							//Create column instance
							var colIns : Column2D =  new Column2D (colMC, this.dataset [i].data [j].w, this.dataset [i].data [j].h, this.dataset [i].plotBorderColor, this.dataset [i].plotBorderAlpha, this.dataset [i].plotBorderThickness, colors, alphas, ratios, this.params.plotFillAngle, false, this.dataset [i].data [j].dashed, this.params.plotBorderDashLen, this.params.plotBorderDashGap);
						}
						//Draw the column
						colIns.draw ();
						//Set x and y position
						colMC._x = this.dataset [i].data [j].x;
						colMC._y = this.dataset [i].data [j].y;
						//Set the alpha of entire column
						colMC._alpha = this.dataset [i].data [j].alpha;
						//Apply animation
						if (this.params.animation)
						{
							this.styleM.applyAnimation (colMC, this.objects.DATAPLOTCOLUMN, this.macro, this.dataset [i].data [j].x, 0, this.dataset [i].data [j].y, 0, 100, 100, 100, null);
						}
						//Apply filters
						this.styleM.applyFilters (colMC, this.objects.DATAPLOTCOLUMN);
						//Event handlers for tool tip
						if (this.params.showToolTip)
						{
							//Create Delegate for roll over function dataOnRollOver
							fnRollOver = Delegate.create (this, dataOnRollOver);
							//Set the index
							fnRollOver.dsindex = i;
							fnRollOver.index = j;
							//Assing the delegates to movie clip handler
							colMC.onRollOver = fnRollOver;
							//Set roll out and mouse move too.
							colMC.onRollOut = colMC.onReleaseOutside = Delegate.create (this, dataOnRollOut);
							colMC.onMouseMove = Delegate.create (this, dataOnMouseMove);
						}
						//Click handler for links - only if link for this column has been defined and click URL
						//has not been defined.
						if (this.dataset [i].data [j].link != "" && this.dataset [i].data [j].link != undefined && this.params.clickURL == "")
						{
							//Create delegate function
							fnClick = Delegate.create (this, dataOnClick);
							//Set index
							fnClick.dsindex = i;
							fnClick.index = j;
							//Assign
							colMC.onRelease = fnClick;
						}
						else
						{
							//Do not use hand cursor
							colMC.useHandCursor = (this.params.clickURL == "") ?false : true;
							//Enable for clickURL
							this.invokeClickURLFromPlots(colMC);
						}
						//Increase depth
						depth ++;
					}
				}
			}
		}
		//Clear interval
		clearInterval (this.config.intervals.plotColumn);
	}
	/**
	* drawLineChart method draws the lines on the chart
	*/
	private function drawLineChart () : Void 
	{
		/**
		* The movie clip structure for each line (dataset) would be :
		* |- Holder
		* |- |- Chart
		* We create child movie clip as we need to animate xscale
		* and y scale. So, we need to position Chart Movie clip at 0,0
		* inside holder movie clip and then readjust Holder movie clip's
		* X and Y Position as per chart's canvas.
		*/
		var m : Number;
		var depth : Number = this.dm.getDepth ("DATAPLOTLINE");
		for (m = 1; m <= this.numDS; m ++)
		{
			//If it's line dataset
			if (this.dataset [m].renderAs == "LINE")
			{
				//Create holder movie clip
				var holderMC : MovieClip = this.cMC.createEmptyMovieClip ("ChartHolder_" + m, depth);
				//Register with object Manager
				objM.register(holderMC, "DATAPLOT_" + m, "DATAPLOTS_"+m)
				//Create chart movie clip inside holder movie clip
				var chartMC : MovieClip = holderMC.createEmptyMovieClip ("Chart", 1);
				//Loop variables
				var i, j;
				//Variables to store the max and min Y positions
				var maxY : Number, minY : Number;
				//Find the index of the first defined data
				//Initialize with (this.num+1) so that if no defined data is found,
				//next loop automatically terminates
				var firstIndex : Number = this.num + 1;
				//Storage container for next plot index
				var nxt : Number;
				for (i = 1; i < this.num; i ++)
				{
					if (this.dataset [m].data [i].isDefined)
					{
						firstIndex = i;
						break;
					}
				}
				//Now, we draw the lines inside chart
				for (i = firstIndex; i < this.num; i ++)
				{
					//We continue only if this data index is defined
					if (this.dataset [m].data [i].isDefined)
					{
						//Get next Index
						nxt = i + 1;
						//Now, if next index is not defined, we can have two cases:
						//1. Draw gap between this data and next data.
						//2. Connect the next index which could be found as defined.
						//Case 1. If connectNullData is set to false and next data is not
						//defined. We simply continue to next value of the loop
						if (this.params.connectNullData == false && this.dataset [m].data [nxt].isDefined == false)
						{
							//Discontinuous plot. So ignore and move to next.
							continue;
						}
						//Now, if nxt data is undefined, we need to find the index of the post data
						//which is not undefined
						if (this.dataset [m].data [nxt].isDefined == false)
						{
							//Initiate nxt as -1, so that we can later break if no next defined data
							//could be found.
							nxt = - 1;
							for (j = i + 1; j <= this.num; j ++)
							{
								if (this.dataset [m].data [j].isDefined == true)
								{
									nxt = j;
									break;
								}
							}
							//If nxt is still -1, we break
							if (nxt == - 1)
							{
								break;
							}
						}
						//Set line style
						chartMC.lineStyle (this.params.lineThickness, parseInt (this.params.lineColor, 16) , this.dataset [m].data [i].alpha);
						//Now, based on whether we've to draw a normal or dashed line, we draw it
						if (this.dataset [m].data [i].dashed)
						{
							//Draw a dashed line
							DrawingExt.dashTo (chartMC, this.dataset [m].data [i].x, this.dataset [m].data [i].y, this.dataset [m].data [nxt].x, this.dataset [m].data [nxt].y, this.params.lineDashLen, this.params.lineDashGap);
						} else 
						{
							//Move to the point
							chartMC.moveTo (this.dataset [m].data [i].x, this.dataset [m].data [i].y);
							//Draw point to next line
							chartMC.lineTo (this.dataset [m].data [nxt].x, this.dataset [m].data [nxt].y);
						}
						//Get maxY and minY
						maxY = (maxY == undefined || (this.dataset [m].data [i].y > maxY)) ? this.dataset [m].data [i].y : maxY;
						minY = (minY == undefined || (this.dataset [m].data [i].y < minY)) ? this.dataset [m].data [i].y : minY;
						//Update loop index (required when connectNullData is true and there is
						//a sequence of empty sets.) Since we've already found the "next" defined
						//data, we update loop to that to optimize.
						i = nxt - 1;
					}
				}
				//Now, we need to adjust the chart movie clip to 0,0 position as center
				chartMC._x = - (this.elements.canvas.w / 2) - this.elements.canvas.x;
				chartMC._y = - (maxY) + ((maxY - minY) / 2);
				//Set the position of holder movie clip now
				holderMC._x = (this.elements.canvas.w / 2) + this.elements.canvas.x;
				holderMC._y = (maxY) - ((maxY - minY) / 2);
				//Apply filter
				this.styleM.applyFilters (holderMC, this.objects.DATAPLOTLINE);
				//Apply animation
				if (this.params.animation)
				{
					this.styleM.applyAnimation (holderMC, this.objects.DATAPLOTLINE, this.macro, holderMC._x, 0, holderMC._y, 0, 100, 100, 100, null);
				}
				//Increment depth
				depth ++;
			}
		}
		//Clear interval
		clearInterval (this.config.intervals.plotLine);
	}
	/**
	* drawAnchors method draws the anchors on the chart
	*/
	private function drawAnchors () : Void 
	{
		//Variables
		var anchorMC : MovieClip;
		var depth : Number = this.dm.getDepth ("ANCHORS");
		var i : Number, j : Number;
		//Create function storage containers for Delegate functions
		var fnRollOver : Function, fnClick : Function;
		//Iterate through all columns
		for (i = 1; i <= this.numDS; i ++)
		{
			//If it's either line or area dataset
			if (this.params.drawAnchors && this.dataset [i].renderAs == "LINE")
			{
				for (j = 1; j <= this.num; j ++)
				{
					//If defined
					if (this.dataset [i].data [j].isDefined)
					{
						//Create an empty movie clip for this anchor
						anchorMC = this.cMC.createEmptyMovieClip ("Anchor_" + i + "_" + j, depth);
						//Register with object Manager
						objM.register(anchorMC, "DATAANCHORS_" + i + "_" + j, "DATAANCHORS_"+i)
						//Set the line style and fill
						anchorMC.lineStyle (this.params.anchorBorderThickness, parseInt (this.params.anchorBorderColor, 16) , 100);
						anchorMC.beginFill (parseInt (this.params.anchorBgColor, 16) , this.params.anchorBgAlpha);
						if(this.params.anchorSides < 3){
							//Draw the circle
							DrawingExt.drawCircle(anchorMC, 0, 0, this.params.anchorRadius, this.params.anchorRadius, 0, 360)
						} else {
							//Draw the polygon
							DrawingExt.drawPoly(anchorMC, 0, 0, this.params.anchorSides, this.params.anchorRadius, 90);
						}
						//Set the x and y Position
						anchorMC._x = this.dataset [i].data [j].x;
						anchorMC._y = this.dataset [i].data [j].y;
						//Set the alpha of entire anchor
						anchorMC._alpha = this.params.anchorAlpha;
						//Apply animation
						if (this.params.animation)
						{
							this.styleM.applyAnimation (anchorMC, this.objects.ANCHORS, this.macro, anchorMC._x, 0, anchorMC._y, 0, this.dataset [i].data [j].anchorAlpha, 100, 100, null);
						}
						//Apply filters
						this.styleM.applyFilters (anchorMC, this.objects.ANCHORS);
						//Event handlers for tool tip
						if (this.params.showToolTip)
						{
							//Create Delegate for roll over function columnOnRollOver
							fnRollOver = Delegate.create (this, dataOnRollOver);
							//Set the index
							fnRollOver.dsindex = i;
							fnRollOver.index = j;
							//Assing the delegates to movie clip handler
							anchorMC.onRollOver = fnRollOver;
							//Set roll out and mouse move too.
							anchorMC.onRollOut = anchorMC.onReleaseOutside = Delegate.create (this, dataOnRollOut);
						}
						//Click handler for links - only if link for this anchor has been defined and click URL
						//has not been defined.
						if (this.dataset [i].data [j].link != "" && this.dataset [i].data [j].link != undefined && this.params.clickURL == "")
						{
							//Create delegate function
							fnClick = Delegate.create (this, dataOnClick);
							//Set index
							fnClick.dsindex = i;
							fnClick.index = j;
							//Assign
							anchorMC.onRelease = fnClick;
						} else 
						{
							//Do not use hand cursor
							anchorMC.useHandCursor = (this.params.clickURL == "") ? false : true;
							//Enable for clickURL
							this.invokeClickURLFromPlots(anchorMC);
						}
						//Increase depth
						depth ++;
					}
				}
			}
		}
		//Clear interval
		clearInterval (this.config.intervals.anchors);
	}
	/**
	* drawColumnValues method draws the values on the chart for columns.
	*/
	private function drawColumnValues () : Void
	{
		//Get value text style
		var valueStyleObj : Object = this.styleM.getTextStyle (this.objects.DATAVALUES);
		//Individual properties
		var isBold : Boolean = valueStyleObj.bold;
		var isItalic : Boolean = valueStyleObj.italic;
		var font : String = valueStyleObj.font;
		var angle : Number = 0;
		//Container object
		var valueObj : MovieClip;
		//Depth
		var depth : Number = this.dm.getDepth ("DATAVALUESCOLUMN");
		//Loop var
		var i : Number, j : Number;
		var yPos : Number;
		var align : String, vAlign : String;
		////Iterate through all columns
		for (i = 1; i <= this.numDS; i ++)
		{
			//If it's column dataset
			if (this.dataset [i].renderAs == "COLUMN")
			{
				for (j = 1; j <= this.num; j ++)
				{
					//If defined and value is to be shown
					if (this.dataset [i].data [j].isDefined && this.dataset [i].data [j].showValue)
					{
						//Get the y position based on placeValuesInside and column height
						if (this.params.placeValuesInside)
						{
							//Vertical alignment position of the value box
							vAlign = (this.dataset [i].data [j].h >= 0) ?"bottom" : "top";
							yPos = (this.dataset [i].data [j].h >= 0) ? (this.dataset [i].data [j].valTBY + this.params.valuePadding) : (this.dataset [i].data [j].valTBY - this.params.valuePadding);
						}else
						{
							vAlign = (this.dataset [i].data [j].h >= 0) ?"top" : "bottom";
							yPos = (this.dataset [i].data [j].h >= 0) ? (this.dataset [i].data [j].valTBY - this.params.valuePadding) : (this.dataset [i].data [j].valTBY + this.params.valuePadding);
						}
						//Align position
						align = "center";
						//Convey alignment to rendering object
						valueStyleObj.align = align;
						valueStyleObj.vAlign = vAlign;
						//Now, if the labels are to be rotated
						if (this.params.rotateValues)
						{
							valueStyleObj.bold = isBold;
							valueStyleObj.italic = isItalic;
							valueStyleObj.font = font;
							angle = 270;
						}else
						{
							//Normal horizontal label - Store original properties
							valueStyleObj.bold = isBold;
							valueStyleObj.italic = isItalic;
							valueStyleObj.font = font;
							angle = 0;
						}
						valueObj = createText (false, this.dataset [i].data [j].displayValue, this.cMC, depth, this.dataset [i].data [j].x, yPos, angle, valueStyleObj, false, 0, 0);
						//Now, we need to adjust those labels which are falling out of height.
						if (this.params.placeValuesInside && ((this.params.valuePadding + valueObj.height) >= Math.abs (this.dataset [i].data [j].h)))
						{
							//If the values are to be placed inside columns, but the height of the column
							//is less than the height of textbox (+ padding), we show the textbox above/below column
							//For non-rotated values
							if ( ! this.params.rotateValues)
							{
								//For positive column
								if (this.dataset [i].data [j].h >= 0)
								{
									//Show above
									valueObj.tf._y = this.dataset [i].data [j].y - this.dataset [i].data [j].h - valueObj.height - this.params.valuePadding;
								}else
								{
									//Negative Column - show below
									valueObj.tf._y = this.dataset [i].data [j].y + Math.abs (this.dataset [i].data [j].h) + this.params.valuePadding;
								}
							}
							else
							{
								//For positive column
								if (this.dataset [i].data [j].h >= 0)
								{
									//Show above
									valueObj.tf._y = this.dataset [i].data [j].y - this.dataset [i].data [j].h - this.params.valuePadding;
								}else
								{
									//Negative Column - show below
									valueObj.tf._y = this.dataset [i].data [j].y + Math.abs (this.dataset [i].data [j].h) + valueObj.height + this.params.valuePadding;
								}
							}
						}
						//Next, we adjust those labels are falling out of top canvas area
						//For Positive columns only
						if (( ! this.params.placeValuesInside) && (this.dataset [i].data [j].h >= 0) && ((yPos - valueObj.height) <= this.elements.canvas.y))
						{
							//Data value is colliding with the upper side of canvas. So we need to place it within
							//the column
							if ( ! this.params.rotateValues)
							{
								valueObj.tf._y = yPos + (2 * this.params.valuePadding);
							}else
							{
								valueObj.tf._y = yPos + (2 * this.params.valuePadding) + valueObj.height;
							}
						}
						//Now, we adjust those labels are falling out of bottom canvas area
						//For Negative Columns Only
						if (( ! this.params.placeValuesInside) && (this.dataset [i].data [j].h < 0) && ((yPos + valueObj.height) >= this.elements.canvas.toY))
						{
							//Data value is colliding with the lower side of canvas. So we need to place it within
							//the column
							if ( ! this.params.rotateValues)
							{
								valueObj.tf._y = yPos - (2 * this.params.valuePadding) - valueObj.height;
							}else
							{
								valueObj.tf._y = yPos - (2 * this.params.valuePadding);
							}
						}
						//Register with object Manager
						objM.register(valueObj.tf, "DATAVALUE_" + i + "_" + j, "DATAVALUES_"+i)
						//Apply filter
						this.styleM.applyFilters (valueObj.tf, this.objects.DATAVALUES);
						//Apply animation
						if (this.params.animation)
						{
							this.styleM.applyAnimation (valueObj.tf, this.objects.DATAVALUES, this.macro, valueObj.tf._x, 0, valueObj.tf._y, 0, 100, null, null, null);
						}
						//Increase depth
						depth ++;
					}
				}
			}
		}
		//Clear interval
		clearInterval (this.config.intervals.dataValuesColumn);
	}
	/**
	* drawLineValues method draws the values on the chart for the lines.
	*/
	private function drawLineValues () : Void 
	{
		//Get value text style
		var valueStyleObj : Object = this.styleM.getTextStyle (this.objects.DATAVALUES);
		//Individual properties
		var isBold : Boolean = valueStyleObj.bold;
		var isItalic : Boolean = valueStyleObj.italic;
		var font : String = valueStyleObj.font;
		var angle : Number = 0;
		//Container object
		var valueObj : MovieClip;
		//Depth
		var depth : Number = this.dm.getDepth ("DATAVALUESLINE");
		//Loop var
		var i : Number, j : Number;
		var yPos : Number;
		var align : String, vAlign : String;
		if (this.params.showLineValues){
			//Iterate through all points
			for (i = 1; i <= this.numDS; i ++)
			{
				//If it's line dataset
				if (this.dataset [i].renderAs == "LINE")
				{
					for (j = 1; j <= this.num; j ++)
					{
						//If defined and value is to be shown
						if (this.dataset [i].data [j].isDefined)
						{
							//Get the y position based on valuePosition & next data's position
							if (this.dataset [i].data [j].valuePosition=="AUTO"){				
								//Get the y position based on next data's position
								if (j == 1)
								{
									//For first point, we show the value on top
									vAlign = "top";
									yPos = this.dataset [i].data [j].valTBY - this.params.valuePadding;
								} else 
								{
									//If this data value is more than that of previous one, we show textbox above
									if (this.dataset [i].data [j].value >= this.dataset [i].data [j - 1].value)
									{
										//Above
										vAlign = "top";
										yPos = this.dataset [i].data [j].valTBY - this.params.valuePadding;
									} else 
									{
										//Below
										vAlign = "bottom";
										yPos = this.dataset [i].data [j].valTBY + this.params.valuePadding;
									}
								}
							}else if(this.dataset [i].data [j].valuePosition=="ABOVE"){
								//Above
								vAlign = "top";
								yPos = this.dataset [i].data [j].valTBY - this.params.valuePadding;
							}else{
								//Below
								vAlign = "bottom";
								yPos = this.dataset [i].data [j].valTBY + this.params.valuePadding;
							}

							//Align position
							align = "center";
							//Convey alignment to rendering object
							valueStyleObj.align = align;
							valueStyleObj.vAlign = vAlign;
							//Now, if the labels are to be rotated
							if (this.params.rotateValues)
							{
								valueStyleObj.bold = isBold;
								valueStyleObj.italic = isItalic;
								valueStyleObj.font = font;
								angle = 270;
							} else 
							{
								//Normal horizontal label - Store original properties
								valueStyleObj.bold = isBold;
								valueStyleObj.italic = isItalic;
								valueStyleObj.font = font;
								angle = 0;
							}
							valueObj = createText (false, this.dataset [i].data [j].displayValue, this.cMC, depth, this.dataset [i].data [j].x, yPos, angle, valueStyleObj, false, 0, 0);
							//Next, we adjust those labels are falling out of top canvas area
							if (((yPos - valueObj.height) <= this.elements.canvas.y))
							{
								//Data value is colliding with the upper side of canvas. So we need to place it within
								//the area
								if ( ! this.params.rotateValues)
								{
									valueObj.tf._y = yPos + (2 * this.params.valuePadding);
								} else 
								{
									valueObj.tf._y = yPos + (2 * this.params.valuePadding) + valueObj.height;
								}
							}
							//Now, we adjust those labels are falling out of bottom canvas area
							if (((yPos + valueObj.height) >= this.elements.canvas.toY))
							{
								//Data value is colliding with the lower side of canvas. So we need to place it within
								//the area
								if ( ! this.params.rotateValues)
								{
									valueObj.tf._y = yPos - (2 * this.params.valuePadding) - valueObj.height;
								} else 
								{
									valueObj.tf._y = yPos - (2 * this.params.valuePadding);
								}
							}
							//Register with object Manager
							objM.register(valueObj.tf, "DATAVALUE_" + i + "_" + j, "DATAVALUES_"+i)
							//Apply filter
							this.styleM.applyFilters (valueObj.tf, this.objects.DATAVALUES);
							//Apply animation
							if (this.params.animation)
							{
								this.styleM.applyAnimation (valueObj.tf, this.objects.DATAVALUES, this.macro, valueObj.tf._x, 0, valueObj.tf._y, 0, 100, null, null, null);
							}
							//Increase depth
							depth ++;
						}
					}
				}
			}
		}
		//Clear interval
		clearInterval (this.config.intervals.dataValuesLine);
	}
	/**
	* setContextMenu method sets the context menu for the chart.
	* For this chart, the context items are "Print Chart".
	*/
	private function setContextMenu () : Void
	{
		var chartMenu : ContextMenu = new ContextMenu ();
		chartMenu.hideBuiltInItems ();
		if (this.params.showPrintMenuItem){
			//Create a print chart contenxt menu item
			var printCMI : ContextMenuItem = new ContextMenuItem ("Print Chart", Delegate.create (this, printChart));
			//Push print item.
			chartMenu.customItems.push (printCMI);
		}
		//If the export data item is to be shown
		if (this.params.showExportDataMenuItem){
			chartMenu.customItems.push(super.returnExportDataMenuItem());
		}
		//Add export chart related menu items to the context menu
		this.addExportItemsToMenu(chartMenu);
		if (this.params.showFCMenuItem){
			//Push "About FusionCharts" Menu Item
			chartMenu.customItems.push(super.returnAbtMenuItem());		
		}
		//Assign the menu to cMC movie clip
		this.cMC.menu = chartMenu;
	}
	// -------------------- EVENT HANDLERS --------------------//
	/**
	* dataOnRollOver is the delegat-ed event handler method that'll
	* be invoked when the user rolls his mouse over a data item.
	* This function is invoked, only if the tool tip is to be shown.
	* Here, we show the tool tip.
	*/
	private function dataOnRollOver () : Void
	{
		//Index of column is stored in arguments.caller.index
		var index : Number = arguments.caller.index;
		var dsindex : Number = arguments.caller.dsindex;
		//Set tool tip text
		this.tTip.setText (this.dataset [dsindex].data [index].toolText);
		//Show the tool tip
		this.tTip.show ();
		//Stop invoke clickURL 
		this.isClickMCPressed = false;
	}
	/**
	* dataOnRollOut method is invoked when the mouse rolls out
	* of column. We just hide the tool tip here.
	*/
	private function dataOnRollOut () : Void
	{
		//Hide the tool tip
		this.tTip.hide ();
		//Stop invoke clickURL 
		this.isClickMCPressed = false;
	}
	/*
	* dataOnMouseMove is called when the mouse position has changed
	* over column. We reposition the tool tip.
	*/
	private function dataOnMouseMove () : Void
	{
		//Reposition the tool tip only if it's in visible state
		if (this.tTip.visible ())
		{
			this.tTip.rePosition ();
		}
	}
	/**
	* dataOnClick is invoked when the user clicks on a column (if link
	* has been defined). We invoke the required link.
	*/
	private function dataOnClick () : Void
	{
		//Index of column is stored in arguments.caller.index
		var dsindex : Number = arguments.caller.dsindex;
		var index : Number = arguments.caller.index;
		//Invoke the link
		super.invokeLink (this.dataset [dsindex].data [index].link);
	}
	/**
	* reInit method re-initializes the chart. This method is basically called
	* when the user changes chart data through JavaScript. In that case, we need
	* to re-initialize the chart, set new XML data and again render.
	*/
	public function reInit () : Void
	{
		//Invoke super class's reInit
		super.reInit ();
		//Now initialize things that are pertinent to this class
		//but not defined in super class.
		this.categories = new Array ();
		this.dataset = new Array ();
		//Initialize the number of data elements present
		this.numDS = 0;
		this.numColDS = 0;
		this.numLineDS = 0;
		this.num = 0;
		this.sum = 0;
		//PlotSpacePercent initially considered as explicitly defined.
		this.defaultPlotSpacePercent = false;
	}
	/**
	* remove method removes the chart by clearing the chart movie clip
	* and removing any listeners.
	*/
	public function remove () : Void 
	{
		super.remove ();
	}
	//---------------DATA EXPORT HANDLERS-------------------//
	/**
	 * Returns the data of the chart in CSV/TSV format. The separator, qualifier and line
	 * break character is stored in params (during common parsing).
	 * @return	The data of the chart in CSV/TSV format, as specified in the XML.
	 */
	public function exportChartDataCSV():String {
		var strData:String = "";
		var strQ:String = this.params.exportDataQualifier;
		var strS:String = this.params.exportDataSeparator;
		var strLB:String = this.params.exportDataLineBreak;
		var i:Number, j:Number;
		strData = strQ + ((this.params.xAxisName!="")?(this.params.xAxisName):("Label")) + strQ + ((this.numDS > 0)? (strS): "");
		//Add all the series names
		for (i = 1; i <= this.numDS; i++) {
			strData += strQ + ((this.dataset[i].seriesName != "")?(this.dataset[i].seriesName):("")) + strQ + ((i < this.numDS)?(strS):(strLB));
		}
		(this.numDS ==0)? strData +=strLB : strData;
		//Iterate through each data-items and add it to the output
		for (i = 1; i <= this.num; i ++)
		{
			//Add the category label
			strData += strQ + (this.categories [i].label)  + strQ + ((this.numDS > 0)? (strS): "");
			//Add the individual value for datasets
			for (j = 1; j <= this.numDS; j ++)
			{
				 strData += strQ + ((this.dataset[j].data[i].isDefined==true)?((this.params.exportDataFormattedVal==true)?(this.dataset[j].data[i].formattedValue):(this.dataset[j].data[i].value)):(""))  + strQ + ((j<this.numDS)?strS:"");
			}
			if (i < this.num) {
				strData += strLB;
			}
		}
		return strData;
	}
}
