/**
* @class MSBar3DChart
* @author FusionCharts Technologies LLP, www.fusioncharts.com
* @version 3.2
*
* Copyright (C) FusionCharts Technologies LLP, 2010
*
* MSBar3DChart chart extends the SingleYAxis3DHorizontalChart class to render a
* Mult-series 3D Bar Chart.
*/
//Import Chart class
import com.fusioncharts.core.Chart;
//Parent SingleYAxis3DHorizontalChart Class
import com.fusioncharts.core.SingleYAxis3DHorizontalChart;
//Error class
import com.fusioncharts.helper.FCError;
//Import Logger Class
import com.fusioncharts.helper.Logger;
//Style Object
import com.fusioncharts.core.StyleObject;
//Delegate
import mx.utils.Delegate;
//Legend Class
import com.fusioncharts.helper.AdvancedLegend;
import com.fusioncharts.helper.LegendIconGenerator;
import flash.display.BitmapData;
//Bars
import com.fusioncharts.core.chartobjects.Bar3D;
//Extensions
import com.fusioncharts.extensions.ColorExt;
import com.fusioncharts.extensions.StringExt;
import com.fusioncharts.extensions.MathExt;
import com.fusioncharts.extensions.DrawingExt;
class com.fusioncharts.core.charts.MSBar3DChart extends SingleYAxis3DHorizontalChart {
	//Version number (if different from super Chart class)
	//private var _version:String = "3.0.0";
	//Instance variables
	//List of chart objects
	private var _arrObjects:Array;
	private var xmlData:XML;
	//Array to store x-axis categories (labels)
	private var categories:Array;
	//Array to store datasets
	private var dataset:Array;
	//Number of data sets
	private var numDS:Number;
	//Number of data items
	private var num:Number;
	//Reference to legend component of chart
	private var lgnd:AdvancedLegend;
	//Reference to legend movie clip
	private var lgndMC:MovieClip;
	//Boolean value to check whether the plotSpacePercent is explicitly defined or calculated as default
	private var defaultPlotSpacePercent : Boolean;
	/**
	* Constructor function. We invoke the super class'
	* constructor and then set the objects for this chart.
	*/
	function MSBar3DChart(targetMC:MovieClip, depth:Number, width:Number, height:Number, x:Number, y:Number, debugMode:Boolean, lang:String, scaleMode:String, registerWithJS:Boolean, DOMId:String) {
		//Invoke the super class constructor
		super(targetMC, depth, width, height, x, y, debugMode, lang, scaleMode, registerWithJS, DOMId);
		//Log additional information to debugger
		//We log version from this class, so that if this class version
		//is different, we can log it		
		this.log("Chart Type", "Multi Series 3D Bar Chart", Logger.LEVEL.INFO);
		_version = getFCVersion();
		this.log("Version", _version, Logger.LEVEL.INFO);
		//List Chart Objects and set them
		_arrObjects = new Array("BACKGROUND", "CANVAS", "CAPTION", "SUBCAPTION", "YAXISNAME", "XAXISNAME", "DIVLINES", "YAXISVALUES", "DATALABELS", "DATAVALUES", "TRENDLINES", "TRENDVALUES", "DATAPLOT", "TOOLTIP", "VLINES", "LEGEND", "VLINELABELS");
		super.setChartObjects(_arrObjects);
		//Initialize the containers for chart
		this.categories = new Array();
		this.dataset = new Array();
		//Initialize the number of data elements present
		this.numDS = 0;
		this.num = 0;
		//PlotSpacePercent initially considered as explicitly defined.
		this.defaultPlotSpacePercent = false;
	}
	/**
	* render method is the single call method that does the rendering of chart:
	* - Parsing XML
	* - Calculating values and co-ordinates
	* - Visual layout and rendering
	* - Event handling
	*/
	public function render(isRedraw:Boolean):Void {
		//Parse the XML Data document
		this.parseXML();
		//If it's a re-draw then do not animate
		if (isRedraw) {
			this.params.animation = false;
			this.defaultGlobalAnimation = 0;
		}
		//Now, if the number of data elements is 0, we show pertinent 
		//error.
		if (this.numDS*this.num == 0) {
			tfAppMsg = this.renderAppMessage(_global.getAppMessage("NODATA", this.lang));
			//Add a message to log.
			this.log("No Data to Display", "No data was found in the XML data document provided. Possible cases can be: <LI>There isn't any data generated by your system. If your system generates data based on parameters passed to it using dataURL, please make sure dataURL is URL Encoded.</LI><LI>You might be using a Single Series Chart .swf file instead of Multi-series .swf file and providing multi-series data or vice-versa.</LI>", Logger.LEVEL.ERROR);
			//Expose rendered method
			this.exposeChartRendered();
			//Also raise the no data event
			if (!isRedraw) {
				this.raiseNoDataExternalEvent();
			}
		} else {
			//Detect number scales
			this.detectNumberScales();
			//Calculate the axis limits
			this.calculateAxisLimits();
			//Calculate exact number of div lines
			this.calcDivs();
			//Set Style defaults
			this.setStyleDefaults();
			//Validate trend lines
			this.validateTrendLines();
			//Allot the depths for various charts objects now
			this.allotDepths();
			//Calculate Points
			this.calculatePoints(isRedraw);
			//Calculate vLine Positions
			this.calcVLinesPos();
			//Calculate trend line positions
			this.calcTrendLinePos();
			//Feed macro values
			this.feedMacros();
			//Remove application message
			this.removeAppMessage(this.tfAppMsg);
			//Set tool tip parameter
			this.setToolTipParam();
			//-----Start Visual Rendering Now------//
			//Draw background
			this.drawBackground();
			//Set click handler
			this.drawClickURLHandler();
			//Load background SWF
			this.loadBgSWF();
			//Update timer
			this.timeElapsed = (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.BACKGROUND) : 0;
			//Draw canvas
			this.config.intervals.canvas = setInterval(Delegate.create(this, drawCanvas), this.timeElapsed);
			//Draw headers
			this.config.intervals.headers = setInterval(Delegate.create(this, drawHeaders), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.CANVAS, this.objects.CAPTION, this.objects.SUBCAPTION, this.objects.YAXISNAME, this.objects.XAXISNAME) : 0;
			//Draw div lines
			this.config.intervals.divLines = setInterval(Delegate.create(this, drawDivLines), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.DIVLINES, this.objects.YAXISVALUES) : 0;
			//Draw labels
			this.config.intervals.labels = setInterval(Delegate.create(this, drawLabels), this.timeElapsed);
			//Draw bars
			this.config.intervals.plot = setInterval(Delegate.create(this, drawBars), this.timeElapsed);
			//Legend
			this.config.intervals.legend = setInterval(Delegate.create(this, drawLegend), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.DATALABELS, this.objects.DATAPLOT, this.objects.LEGEND) : 0;
			//Data Values
			this.config.intervals.dataValues = setInterval(Delegate.create(this, drawValues), this.timeElapsed);
			//Draw trend lines
			this.config.intervals.trend = setInterval(Delegate.create(this, drawTrendLines), this.timeElapsed);
			//Draw vertical div lines
			this.config.intervals.vLine = setInterval(Delegate.create(this, drawVLines), this.timeElapsed);
			//Update timer
			this.timeElapsed += (this.params.animation) ? this.styleM.getMaxAnimationTime(this.objects.TRENDLINES, this.objects.TRENDVALUES, this.objects.VLINES, this.objects.DATAVALUES) : 0;
			//Dispatch event that the chart has loaded.
			this.config.intervals.renderedEvent = setInterval(Delegate.create(this, exposeChartRendered), this.timeElapsed);
			//Render context menu
			//We do not put context menu interval as we need the menu to appear
			//right from start of the play.
			this.setContextMenu();
		}
	}
	/**
	* returnDataAsObject method creates an object out of the parameters
	* passed to this method. The idea is that we store each data point
	* as an object with multiple (flexible) properties. So, we do not
	* use a predefined class structure. Instead we use a generic object.
	*	@param	value		Value for the bar.
	*	@param	color		Hex Color code (or comma separated list).
	* 	@param	displayValue	Value that will be displayed on the chart
	*	@param	alpha		List of alphas separated by comma
	*	@param	toolText	Tool tip text (if specified).
	*	@param	link		Link (if any) for the bar.
	*	@param	showValue	Flag to show/hide value for this bar.
	*	@param	isDashed	Flag whether the bar would have dashed border.
	*	@return			An object encapsulating all these properies.
	*/
	private function returnDataAsObject(value:Number, color:String, displayValue:String, alpha:Number, toolText:String, link:String, showValue:Number):Object {
		//Create a container
		var dataObj:Object = new Object();
		//Store the values
		dataObj.value = value;
		//Explicitly specified display value
		dataObj.exDispVal = displayValue;
		//Extract and save colors, ratio, alpha as array so that we do not have to parse later.
		dataObj.color = color;
		dataObj.alpha = alpha;
		dataObj.toolText = toolText;
		dataObj.link = link;
		dataObj.showValue = (showValue == 1) ? true : false;
		//If the given number is not a valid number or it's missing
		//set appropriate flags for this data point
		dataObj.isDefined = ((dataObj.alpha == 0) || isNaN(value)) ? false : true;
		//Other parameters
		//X & Y Position of data point
		dataObj.x = 0;
		dataObj.y = 0;
		//Width and height
		dataObj.w = 0;
		dataObj.h = 0;
		//X & Y Position of value tb
		dataObj.valTBX = 0;
		dataObj.valTBY = 0;
		//Return the container
		return dataObj;
	}
	/**
	* returnDataAsCat method returns data of a <category> element as
	* an object
	*	@param	label		Label of the category.
	*	@param	showLabel	Whether to show the label of this category.
	*	@param	toolText	Tool-text for the category
	*	@return			A container object with the given properties
	*/
	private function returnDataAsCat(label:String, showLabel:Number, toolText:String):Object {
		//Create container object
		var catObj:Object = new Object();
		catObj.label = label;
		catObj.showLabel = ((showLabel == 1) && (label != undefined) && (label != null) && (label != "")) ? true : false;
		catObj.toolText = toolText;
		//X and Y Position
		catObj.x = 0;
		catObj.y = 0;
		//Return container
		return catObj;
	}
	/**
	* parseXML method parses the XML data, sets defaults and validates
	* the attributes before storing them to data storage objects.
	*/
	private function parseXML():Void {
		//Get the element nodes
		var arrDocElement:Array = this.xmlData.childNodes;
		//Loop variable
		var i:Number;
		var j:Number;
		var k:Number;
		//Look for <graph> element
		for (i=0; i<arrDocElement.length; i++) {
			//If it's a <graph> element, proceed.
			//Do case in-sensitive mathcing by changing to upper case
			if (arrDocElement[i].nodeName.toUpperCase() == "GRAPH" || arrDocElement[i].nodeName.toUpperCase() == "CHART") {
				//Extract attributes of <graph> element
				this.parseAttributes(arrDocElement[i]);
				//Extract common attributes/over-ride chart specific ones
				this.parseCommonAttributes(arrDocElement[i], false);
				//Now, get the child nodes - first level nodes
				//Level 1 nodes can be - CATEGORIES, DATASET, TRENDLINES, STYLES etc.
				var arrLevel1Nodes:Array = arrDocElement[i].childNodes;
				var setNode:XMLNode;
				//Iterate through all level 1 nodes.
				for (j=0; j<arrLevel1Nodes.length; j++) {
					if (arrLevel1Nodes[j].nodeName.toUpperCase() == "CATEGORIES") {
						//Categories Node.
						var categoriesNode:XMLNode = arrLevel1Nodes[j];
						//Convert attributes to array
						var categoriesAtt:Array = this.getAttributesArray(categoriesNode);
						//Extract attributes of this node.
						this.params.catFont = getFV(categoriesAtt["font"], this.params.outCnvBaseFont);
						this.params.catFontSize = getFN(categoriesAtt["fontsize"], this.params.outCnvBaseFontSize);
						this.params.catFontColor = formatColor(getFV(categoriesAtt["fontcolor"], this.params.outCnvBaseFontColor));
						//Get reference to child node.
						var arrLevel2Nodes:Array = arrLevel1Nodes[j].childNodes;
						//Iterate through all child-nodes of CATEGORIES element
						//and search for CATEGORY or VLINE node
						for (k=0; k<arrLevel2Nodes.length; k++) {
							if (arrLevel2Nodes[k].nodeName.toUpperCase() == "CATEGORY") {
								//Category Node.
								//Update counter
								this.num++;
								//Extract attributes
								var categoryNode:XMLNode = arrLevel2Nodes[k];
								var categoryAtt:Array = this.getAttributesArray(categoryNode);
								//Category label.
								var catLabel:String = getFV(categoryAtt["label"], categoryAtt["name"], "");
								var catShowLabel:Number = getFN(categoryAtt["showlabel"], categoryAtt["showname"], this.params.showLabels);
								var catToolText:String = getFV(categoryAtt["tooltext"], categoryAtt["hovertext"], catLabel);
								//Store it in data container.
								this.categories[this.num] = this.returnDataAsCat(catLabel, catShowLabel, catToolText);
							} else if (arrLevel2Nodes[k].nodeName.toUpperCase() == "VLINE") {
								//Vertical axis division Node - extract child nodes
								var vLineNode:XMLNode = arrLevel2Nodes[k];
								//Parse and store
								this.parseVLineNode(vLineNode, this.num);
							}
						}
					} else if (arrLevel1Nodes[j].nodeName.toUpperCase() == "DATASET") {
						//Increment
						this.numDS++;
						//Dataset node.
						var dataSetNode:XMLNode = arrLevel1Nodes[j];
						//Get attributes array
						var dsAtts:Array = this.getAttributesArray(dataSetNode);
						//Create storage object in dataset array
						this.dataset[this.numDS] = new Object();
						//Store attributes
						this.dataset[this.numDS].seriesName = getFV(dsAtts["seriesname"], "");
						this.dataset[this.numDS].color = formatColor (getFV(dsAtts["color"], this.defColors.getColor()));
						this.dataset[this.numDS].alpha = getFN(dsAtts["alpha"], this.params.plotFillAlpha);
						this.dataset[this.numDS].showValues = toBoolean(getFN(dsAtts["showvalues"], this.params.showValues));
						this.dataset[this.numDS].includeInLegend = toBoolean(getFN(dsAtts["includeinlegend"], 1));
						//Create data array under it.
						this.dataset[this.numDS].data = new Array();
						//Get reference to child node.
						var arrLevel2Nodes:Array = arrLevel1Nodes[j].childNodes;
						//Iterate through all child-nodes of DATASET element
						//and search for SET node
						//Counter
						var setCount:Number = 0;
						//Whether any plot is visible
						var anyPlotVisible:Boolean = false;
						for (k=0; k<arrLevel2Nodes.length; k++) {
							if (arrLevel2Nodes[k].nodeName.toUpperCase() == "SET") {
								//Set Node. So extract the data.
								//Update counter
								setCount++;
								//Get reference to node.
								setNode = arrLevel2Nodes[k];
								//Get attributes
								var atts:Array;
								atts = this.getAttributesArray(setNode);
								//Now, get value.
								var setValue:Number = this.getSetValue(atts["value"]);
								//Get explicitly specified display value
								var setExDispVal:String = getFV(atts["displayvalue"], "");
								//We do NOT unescape the link, as this will be done
								//in invokeLink method for the links that user clicks.
								var setLink:String = getFV(atts["link"], "");
								var setToolText:String = getFV(atts["tooltext"], atts["hovertext"]);
								var setColor:String = formatColor (getFV(atts["color"], this.dataset[this.numDS].color));
								var setAlpha:Number = getFN(atts["alpha"], this.dataset[this.numDS].alpha);
								var setShowValue:Number = getFN(atts["showvalue"], this.dataset[this.numDS].showValues);
								//Whether plots are to be shown or not
								if(!anyPlotVisible){
									if(!isNaN(setValue) && setAlpha > 0){
										anyPlotVisible = true;
									}
								}
								//Store all these attributes as object.
								this.dataset[this.numDS].data[setCount] = this.returnDataAsObject(setValue, setColor, setExDispVal, setAlpha, setToolText, setLink, setShowValue);
								//Update numNeg, numPos based on set value
								if (setValue<0) {
									//Update negative count
									numNeg++;
								} else {
									//Update positive count
									numPos++;
								}
							}
						}
						//If any plot is visible in the dataset, that dataset's legend item should appear.
						//Also it has to consider that dataset legend is included.
						if(this.dataset [this.numDS].includeInLegend){
							this.dataset [this.numDS].includeInLegend = (!anyPlotVisible)? false: true;
						}
					} else if (arrLevel1Nodes[j].nodeName.toUpperCase() == "STYLES") {
						//Styles Node - extract child nodes
						var arrStyleNodes:Array = arrLevel1Nodes[j].childNodes;
						//Parse the style nodes to extract style information
						super.parseStyleXML(arrStyleNodes);
					} else if (arrLevel1Nodes[j].nodeName.toUpperCase() == "TRENDLINES") {
						//Trend lines node
						var arrTrendNodes:Array = arrLevel1Nodes[j].childNodes;
						//Parse the trend line nodes
						super.parseTrendLineXML(arrTrendNodes);
					}
				}
			}
		}
		//Delete all temporary objects used for parsing XML Data document
		delete setNode;
		delete arrDocElement;
		delete arrLevel1Nodes;
		delete arrLevel2Nodes;
	}
	/**
	* parseAttributes method parses the attributes and stores them in
	* chart storage objects.
	* Starting ActionScript 2, the parsing of XML attributes have also
	* become case-sensitive. However, prior versions of FusionCharts
	* supported case-insensitive attributes. So we need to parse all
	* attributes as case-insensitive to maintain backward compatibility.
	* To do so, we first extract all attributes from XML, convert it into
	* lower case and then store it in an array. Later, we extract value from
	* this array.
	* @param	graphElement	XML Node containing the <graph> element
	*							and it's attributes
	*/
	private function parseAttributes(graphElement:XMLNode):Void {
		//Array to store the attributes
		var atts:Array = this.getAttributesArray(graphElement);
		//NOW IT'S VERY NECCESARY THAT WHEN WE REFERENCE THIS ARRAY
		//TO GET AN ATTRIBUTE VALUE, WE SHOULD PROVIDE THE ATTRIBUTE
		//NAME IN LOWER CASE. ELSE, UNDEFINED VALUE WOULD SHOW UP.
		//Extract attributes pertinent to this chart
		//Which palette to use?
		this.params.palette = getFN(atts["palette"], 1);
		//Palette colors to use
		this.params.paletteColors = getFV(atts["palettecolors"], "");
		//Set palette colors before parsing the <set> nodes.
		this.setPaletteColors();
		// ---------- PADDING AND SPACING RELATED ATTRIBUTES ----------- //
		//captionPadding = Space between caption/subcaption and canvas start Y
		this.params.captionPadding = getFN(atts["captionpadding"], 10);
		//canvasPadding - Padding on the canvas on top and bottom side of bar
		this.params.canvasPadding = getFN(atts["canvaspadding"], 10);
		//Padding for x-axis name - to the left
		this.params.xAxisNamePadding = getFN(atts["xaxisnamepadding"], 5);
		//Padding for y-axis name - to right
		this.params.yAxisNamePadding = getFN(atts["yaxisnamepadding"], 5);
		//Y-Axis Values padding - Vertical space between the axis edge and
		//y-axis values or trend line values.
		this.params.yAxisValuesPadding = getFN(atts["yaxisvaluespadding"], 2);
		//Label padding - Horizontal space between the labels and canvas start position
		this.params.labelPadding = getFN(atts["labelpadding"], atts["labelspadding"], 3);
		//Value padding - Horizontal space between the end of bars and start of value textboxes
		this.params.valuePadding = getFN(atts["valuepadding"], 2);
		//Percentage space on the plot area
		this.params.plotSpacePercent = Number (atts ["plotspacepercent"]);
		///Cannot be less than 0 and more than 80
		if ((this.params.plotSpacePercent < 0) || (this.params.plotSpacePercent > 80) || isNaN(this.params.plotSpacePercent))
		{
			//Reset to 20
			this.params.plotSpacePercent = 20;
			this.defaultPlotSpacePercent = true;
		}
		//Padding of legend from right/bottom side of canvas 
		this.params.legendPadding = getFN(atts["legendpadding"], 6);
		//Chart Margins - Empty space at the 4 sides
		this.params.chartLeftMargin = getFN(atts["chartleftmargin"], 15);
		this.params.chartRightMargin = getFN(atts["chartrightmargin"], 30);
		this.params.chartTopMargin = getFN(atts["charttopmargin"], 15);
		this.params.chartBottomMargin = getFN(atts["chartbottommargin"], 15);
		// -------------------------- HEADERS ------------------------- //
		//Chart Caption and sub Caption
		this.params.caption = getFV(atts["caption"], "");
		this.params.subCaption = getFV(atts["subcaption"], "");
		//X and Y Axis Name
		this.params.xAxisName = getFV(atts["xaxisname"], "");
		this.params.yAxisName = getFV(atts["yaxisname"], "");
		//Adaptive yMin - if set to true, the y min will be based on the values
		//provided. It won't be set to 0 in case of all positive values
		this.params.setAdaptiveYMin = toBoolean(getFN(atts["setadaptiveymin"], 0));
		// --------------------- CONFIGURATION ------------------------- //
		//The upper and lower limits of y and x axis
		this.params.yAxisMinValue = atts["yaxisminvalue"];
		this.params.yAxisMaxValue = atts["yaxismaxvalue"];
		//Whether to set animation for entire chart.
		this.params.animation = toBoolean(getFN(this.defaultGlobalAnimation, atts["animation"], 1));
		//Whether to set the default chart animation
		this.params.defaultAnimation = toBoolean(getFN(atts["defaultanimation"], 1));
		//Whether to overlap bars
		this.params.overlapBars = atts["overlapbars"];
		//Maximum allowed bar height
		this.params.maxBarHeight = getFN(atts["maxbarheight"], 100);
		//If maxBarHeight < 0 make absolute value of it
		this.params.maxBarHeight = (this.params.maxBarHeight < 0) ? Math.abs(this.params.maxBarHeight) : this.params.maxBarHeight ;
		//If maxBarHeight is zero reset  it to 1
		this.params.maxBarHeight = (this.params.maxBarHeight == 0) ? 1 : this.params.maxBarHeight ;
		//Configuration to set whether to show the labels
		this.params.showLabels = toBoolean(getFN(atts["showlabels"], atts["shownames"], 1));
		//Maximum label width percent
		this.params.maxLabelWidthPercent = getFN (atts ["maxlabelwidthpercent"] , 65);
		//Step value for labels - i.e., show all labels or skip every x label
		this.params.labelStep = int(getFN(atts["labelstep"], 1));
		//Cannot be less than 1
		this.params.labelStep = (this.params.labelStep<1) ? 1 : this.params.labelStep;
		//Configuration whether to show data values
		this.params.showValues = toBoolean(getFN(atts["showvalues"], 1));
		//Whether to place values inside bar
		this.params.placeValuesInside = toBoolean(getFN(atts["placevaluesinside"], 0));
		//Option to show/hide y-axis values
		this.params.showYAxisValues = getFN(atts["showyaxisvalues"], atts["showyaxisvalue"], 1);
		this.params.showLimits = toBoolean(getFN(atts["showlimits"], this.params.showYAxisValues));
		this.params.showDivLineValues = toBoolean(getFN(atts["showdivlinevalue"], atts["showdivlinevalues"], this.params.showYAxisValues));
		//Y-axis value step- i.e., show all y-axis or skip every x(th) value
		this.params.yAxisValuesStep = int(getFN(atts["yaxisvaluesstep"], atts["yaxisvaluestep"], 1));
		//Cannot be less than 1
		this.params.yAxisValuesStep = (this.params.yAxisValuesStep<1) ? 1 : this.params.yAxisValuesStep;
		//Whether to automatically adjust div lines
		this.params.adjustDiv = toBoolean(getFN(atts["adjustdiv"], 1));
		//Whether to rotate x-axis name
		this.params.rotateXAxisName = toBoolean(getFN(atts["rotatexaxisname"], 1));
		//Max width to be alloted to x-axis name - No defaults, as it's calculated later.
		this.params.xAxisNameWidth = atts["xaxisnamewidth"];
		//Bar Depth
		this.params.barDepth = getFN(atts["bardepth"], -1);
		//Click URL
		this.params.clickURL = getFV(atts["clickurl"], "");
		// ------------------------- COSMETICS -----------------------------//
		//Whether to use 3D Lighting
		this.params.use3DLighting = toBoolean(getFN(atts["use3dlighting"], 1));
		//Show bar shadows
		this.params.showShadow = toBoolean(getFN(atts["showshadow"], this.params.use3DLighting));
		//Background properties - Gradient
		this.params.bgColor = getFV(atts["bgcolor"], this.defColors.getBgColor3D(this.params.palette));
		this.params.bgAlpha = getFV(atts["bgalpha"], this.defColors.getBgAlpha3D(this.params.palette));
		this.params.bgRatio = getFV(atts["bgratio"], this.defColors.getBgRatio3D(this.params.palette));
		this.params.bgAngle = getFV(atts["bgangle"], this.defColors.getBgAngle3D(this.params.palette));
		//Border Properties of chart
		this.params.showBorder = toBoolean(getFN(atts["showborder"], 0));
		this.params.borderColor = formatColor(getFV(atts["bordercolor"], "666666"));
		this.params.borderThickness = getFN(atts["borderthickness"], 1);
		this.params.borderAlpha = getFN(atts["borderalpha"], 100);
		//Canvas background properties
		this.params.canvasBgColor = formatColor(getFV(atts["canvasbgcolor"], this.defColors.getCanvasBgColor3D(this.params.palette)));
		this.params.canvasBgAlpha = getFN(atts["canvasbgalpha"], 100);
		this.params.canvasBaseColor = formatColor(getFV(atts["canvasbasecolor"], this.defColors.getCanvasBaseColor3D(this.params.palette)));
		//Option to show/hide canvas base and bg
		this.params.showCanvasBg = toBoolean(getFN(atts["showcanvasbg"], 1));
		this.params.showCanvasBase = toBoolean(getFN(atts["showcanvasbase"], 1));
		//Depth of background and base
		this.params.canvasBaseDepth = getFN(atts["canvasbasedepth"], 10);
		this.params.canvasBgDepth = getFN(atts["canvasbgdepth"], 3);
		//Plot cosmetic properties
		this.params.showPlotBorder = toBoolean(getFN(atts["showplotborder"], 0));
		this.params.plotBorderColor = formatColor(getFV(atts["plotbordercolor"], "FFFFFF"));
		this.params.plotBorderAlpha = getFN(atts["plotborderalpha"], (this.params.showPlotBorder == true) ? 95 : 0);
		//Fill properties
		this.params.plotFillAlpha = getFN(atts["plotfillalpha"], 100);
		//Legend properties
		this.params.showLegend = toBoolean(getFN(atts["showlegend"], 1));
		//Alignment position
		this.params.legendPosition = getFV(atts["legendposition"], "BOTTOM");
		//Legend position can be either RIGHT or BOTTOM -Check for it
		this.params.legendPosition = (this.params.legendPosition.toUpperCase() == "RIGHT") ? "RIGHT" : "BOTTOM";
		this.params.interactiveLegend = toBoolean(getFN(atts["interactivelegend"], 1));
		this.params.legendCaption = getFV(atts["legendcaption"], "");
		this.params.legendMarkerCircle = toBoolean(getFN(atts["legendmarkercircle"], 0));
		this.params.legendBorderColor = formatColor(getFV(atts["legendbordercolor"], this.defColors.getLegendBorderColor3D(this.params.palette)));
		this.params.legendBorderThickness = getFN(atts["legendborderthickness"], 1);
		this.params.legendBorderAlpha = getFN(atts["legendborderalpha"], 100);
		this.params.legendBgColor = formatColor (getFV(atts["legendbgcolor"], this.defColors.getLegendBgColor3D(this.params.palette)));
		this.params.legendBgAlpha = getFN(atts["legendbgalpha"], 100);
		this.params.legendShadow = toBoolean(getFN(atts["legendshadow"], 1));
		this.params.legendAllowDrag = toBoolean(getFN(atts["legendallowdrag"], 0));
		this.params.legendScrollBgColor = formatColor(getFV(atts["legendscrollbgcolor"], "CCCCCC"));
		this.params.legendScrollBarColor = formatColor(getFV(atts["legendscrollbarcolor"], this.params.legendBorderColor));
		this.params.legendScrollBtnColor = formatColor(getFV(atts["legendscrollbtncolor"], this.params.legendBorderColor));
		this.params.reverseLegend = toBoolean(getFN(atts["reverselegend"], 0));
		this.params.legendIconScale = getFN(atts["legendiconscale"], 1);
		if (this.params.legendIconScale<=0 || this.params.legendIconScale>5) {
			this.params.legendIconScale = 1;
		}
		this.params.legendNumColumns = Math.round(getFN(atts["legendnumcolumns"], 0));
		if (this.params.legendNumColumns<0) {
			this.params.legendNumColumns = 0;
		}
		this.params.minimiseWrappingInLegend = toBoolean(getFN(atts["minimisewrappinginlegend"], 0));
		//Horizontal grid division Lines - Number, color, thickness & alpha
		//Necessarily need a default value for numDivLines.
		this.params.numDivLines = getFN(atts["numdivlines"], 4);
		this.params.divLineColor = formatColor(getFV(atts["divlinecolor"], this.defColors.getDivLineColor3D(this.params.palette)));
		this.params.divLineThickness = getFN(atts["divlinethickness"], 1);
		this.params.divLineAlpha = getFN(atts["divlinealpha"], 100);
		this.params.divLineIsDashed = toBoolean(getFN(atts["divlineisdashed"], 0));
		this.params.divLineDashLen = getFN(atts["divlinedashlen"], 4);
		this.params.divLineDashGap = getFN(atts["divlinedashgap"], 2);
		//Zero Plane properties
		this.params.showZeroPlane = true;
		this.params.zeroPlaneColor = formatColor(getFV(atts["zeroplanecolor"], this.params.divLineColor));
		this.params.zeroPlaneAlpha = getFN(atts["zeroplanealpha"], 75);
		this.params.zeroPlaneShowBorder = toBoolean(getFN(atts["zeroplaneshowborder"], 1));
		this.params.zeroPlaneBorderColor = formatColor(getFV(atts["zeroplanebordercolor"], this.params.zeroPlaneColor));
		// ------------------------- NUMBER FORMATTING ---------------------------- //
		//Option whether the format the number (using Commas)
		this.params.formatNumber = toBoolean(getFN(atts["formatnumber"], 1));
		//Option to format number scale
		this.params.formatNumberScale = toBoolean(getFN(atts["formatnumberscale"], 1));
		//Number Scales
		this.params.defaultNumberScale = getFV(atts["defaultnumberscale"], "");
		this.params.numberScaleUnit = getFV(atts["numberscaleunit"], "K,M");
		this.params.numberScaleValue = getFV(atts["numberscalevalue"], "1000,1000");
		//Number prefix and suffix
		this.params.numberPrefix = getFV(atts["numberprefix"], "");
		this.params.numberSuffix = getFV(atts["numbersuffix"], "");
		//whether to scale recursively
		this.params.scaleRecursively = toBoolean( getFN (atts ['scalerecursively'], 0));
		//By default we show all - so set as -1
		this.params.maxScaleRecursion = getFN(atts["maxscalerecursion"], -1);
		//Setting space as default scale separator.
		this.params.scaleSeparator = getFV(atts["scaleseparator"] , " ");
		//Decimal Separator Character
		this.params.decimalSeparator = getFV(atts["decimalseparator"], ".");
		//Thousand Separator Character
		this.params.thousandSeparator = getFV(atts["thousandseparator"], ",");
		//Input decimal separator and thousand separator. In some european countries,
		//commas are used as decimal separators and dots as thousand separators. In XML,
		//if the user specifies such values, it will give a error while converting to
		//number. So, we accept the input decimal and thousand separator from user, so that
		//we can covert it accordingly into the required format.
		this.params.inDecimalSeparator = getFV(atts["indecimalseparator"], "");
		this.params.inThousandSeparator = getFV(atts["inthousandseparator"], "");
		//Decimal Precision (number of decimal places to be rounded to)
		this.params.decimals = getFV(atts["decimals"], atts["decimalprecision"]);
		//Force Decimal Padding
		this.params.forceDecimals = toBoolean(getFN(atts["forcedecimals"], 0));
		//y-Axis values decimals
		this.params.yAxisValueDecimals = getFV(atts["yaxisvaluedecimals"], atts["yaxisvaluesdecimals"], atts["divlinedecimalprecision"], atts["limitsdecimalprecision"]);
	}
	/**
	* getMaxDataValue method gets the maximum y-axis data value present
	* in the data.
	*	@return	The maximum value present in the data provided.
	*/
	private function getMaxDataValue():Number {
		var maxValue:Number;
		var firstNumberFound:Boolean = false;
		var i:Number, j:Number;
		for (i=1; i<=this.numDS; i++) {
			for (j=1; j<=this.num; j++) {
				//By default assume the first non-null number to be maximum
				if (firstNumberFound == false) {
					if (this.dataset[i].data[j].isDefined == true) {
						//Set the flag that "We've found first non-null number".
						firstNumberFound = true;
						//Also assume this value to be maximum.
						maxValue = this.dataset[i].data[j].value;
					}
				} else {
					//If the first number has been found and the current data is defined, compare
					if (this.dataset[i].data[j].isDefined) {
						//Store the greater number
						maxValue = (this.dataset[i].data[j].value>maxValue) ? this.dataset[i].data[j].value : maxValue;
					}
				}
			}
		}
		return maxValue;
	}
	/**
	* getMinDataValue method gets the minimum y-axis data value present
	* in the data
	*	@reurns		The minimum value present in data
	*/
	private function getMinDataValue():Number {
		var minValue:Number;
		var firstNumberFound:Boolean = false;
		var i:Number, j:Number;
		for (i=1; i<=this.numDS; i++) {
			for (j=1; j<=this.num; j++) {
				//By default assume the first non-null number to be minimum
				if (firstNumberFound == false) {
					if (this.dataset[i].data[j].isDefined == true) {
						//Set the flag that "We've found first non-null number".
						firstNumberFound = true;
						//Also assume this value to be minimum.
						minValue = this.dataset[i].data[j].value;
					}
				} else {
					//If the first number has been found and the current data is defined, compare
					if (this.dataset[i].data[j].isDefined) {
						//Store the lesser number
						minValue = (this.dataset[i].data[j].value<minValue) ? this.dataset[i].data[j].value : minValue;
					}
				}
			}
		}
		return minValue;
	}
	/**
	* calculateAxisLimits method sets the axis limits for the chart.
	* It gets the minimum and maximum value specified in data and
	* based on that it calls super.getAxisLimits();
	*/
	private function calculateAxisLimits():Void {
		this.getAxisLimits(this.getMaxDataValue(), this.getMinDataValue(), ! this.params.setAdaptiveYMin, !this.params.setAdaptiveYMin);
	}
	/**
	* setStyleDefaults method sets the default values for styles or
	* extracts information from the attributes and stores them into
	* style objects.
	*/
	private function setStyleDefaults():Void {
		//Default font object for Caption
		//-----------------------------------------------------------------//
		var captionFont = new StyleObject();
		captionFont.name = "_SdCaptionFont";
		captionFont.align = "center";
		captionFont.valign = "top";
		captionFont.bold = "1";
		captionFont.font = this.params.outCnvBaseFont;
		captionFont.size = this.params.outCnvBaseFontSize+3;
		captionFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.CAPTION, captionFont, this.styleM.TYPE.FONT, null);
		delete captionFont;
		//-----------------------------------------------------------------//
		//Default font object for SubCaption
		//-----------------------------------------------------------------//
		var subCaptionFont = new StyleObject();
		subCaptionFont.name = "_SdSubCaptionFont";
		subCaptionFont.align = "center";
		subCaptionFont.valign = "top";
		subCaptionFont.bold = "1";
		subCaptionFont.font = this.params.outCnvBaseFont;
		subCaptionFont.size = this.params.outCnvBaseFontSize+1;
		subCaptionFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.SUBCAPTION, subCaptionFont, this.styleM.TYPE.FONT, null);
		delete subCaptionFont;
		//-----------------------------------------------------------------//
		//Default font object for YAxisName
		//-----------------------------------------------------------------//
		var yAxisNameFont = new StyleObject();
		yAxisNameFont.name = "_SdYAxisNameFont";
		yAxisNameFont.align = "center";
		yAxisNameFont.valign = "middle";
		yAxisNameFont.bold = "1";
		yAxisNameFont.font = this.params.outCnvBaseFont;
		yAxisNameFont.size = this.params.outCnvBaseFontSize;
		yAxisNameFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.YAXISNAME, yAxisNameFont, this.styleM.TYPE.FONT, null);
		delete yAxisNameFont;
		//-----------------------------------------------------------------//
		//Default font object for XAxisName
		//-----------------------------------------------------------------//
		var xAxisNameFont = new StyleObject();
		xAxisNameFont.name = "_SdXAxisNameFont";
		xAxisNameFont.align = "center";
		xAxisNameFont.valign = "middle";
		xAxisNameFont.bold = "1";
		xAxisNameFont.font = this.params.outCnvBaseFont;
		xAxisNameFont.size = this.params.outCnvBaseFontSize;
		xAxisNameFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.XAXISNAME, xAxisNameFont, this.styleM.TYPE.FONT, null);
		delete xAxisNameFont;
		//-----------------------------------------------------------------//
		//Default font object for trend lines
		//-----------------------------------------------------------------//
		var trendFont = new StyleObject();
		trendFont.name = "_SdTrendFont";
		trendFont.font = this.params.outCnvBaseFont;
		trendFont.size = this.params.outCnvBaseFontSize;
		trendFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.TRENDVALUES, trendFont, this.styleM.TYPE.FONT, null);
		delete trendFont;
		//-----------------------------------------------------------------//
		//Default font object for yAxisValues
		//-----------------------------------------------------------------//
		var yAxisValuesFont = new StyleObject();
		yAxisValuesFont.name = "_SdYAxisValuesFont";
		yAxisValuesFont.align = "right";
		yAxisValuesFont.valign = "middle";
		yAxisValuesFont.font = this.params.outCnvBaseFont;
		yAxisValuesFont.size = this.params.outCnvBaseFontSize;
		yAxisValuesFont.color = this.params.outCnvBaseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.YAXISVALUES, yAxisValuesFont, this.styleM.TYPE.FONT, null);
		delete yAxisValuesFont;
		//-----------------------------------------------------------------//
		//Default font object for DataLabels
		//-----------------------------------------------------------------//
		var dataLabelsFont = new StyleObject();
		dataLabelsFont.name = "_SdDataLabelsFont";
		dataLabelsFont.align = "center";
		dataLabelsFont.valign = "bottom";
		dataLabelsFont.font = this.params.catFont;
		dataLabelsFont.size = this.params.catFontSize;
		dataLabelsFont.color = this.params.catFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.DATALABELS, dataLabelsFont, this.styleM.TYPE.FONT, null);
		delete dataLabelsFont;
		//-----------------------------------------------------------------//
		//Default font object for Legend
		//-----------------------------------------------------------------//
		var legendFont = new StyleObject();
		legendFont.name = "_SdLegendFont";
		legendFont.font = this.params.outCnvBaseFont;
		legendFont.size = this.params.outCnvBaseFontSize;
		legendFont.color = this.params.outCnvBaseFontColor;
		legendFont.ishtml = 1;
		legendFont.leftmargin = 3;
		//Over-ride
		this.styleM.overrideStyle(this.objects.LEGEND, legendFont, this.styleM.TYPE.FONT, null);
		delete legendFont;
		//-----------------------------------------------------------------//
		//Default font object for DataValues
		//-----------------------------------------------------------------//
		var dataValuesFont = new StyleObject();
		dataValuesFont.name = "_SdDataValuesFont";
		dataValuesFont.align = "center";
		dataValuesFont.valign = "middle";
		dataValuesFont.font = this.params.baseFont;
		dataValuesFont.size = this.params.baseFontSize;
		dataValuesFont.color = this.params.baseFontColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.DATAVALUES, dataValuesFont, this.styleM.TYPE.FONT, null);
		delete dataValuesFont;
		//-----------------------------------------------------------------//
		//Default font object for ToolTip
		//-----------------------------------------------------------------//
		var toolTipFont = new StyleObject();
		toolTipFont.name = "_SdToolTipFont";
		toolTipFont.font = this.params.baseFont;
		toolTipFont.size = this.params.baseFontSize;
		toolTipFont.color = this.params.baseFontColor;
		toolTipFont.bgcolor = this.params.toolTipBgColor;
		toolTipFont.bordercolor = this.params.toolTipBorderColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.TOOLTIP, toolTipFont, this.styleM.TYPE.FONT, null);
		delete toolTipFont;
		//-----------------------------------------------------------------//
		//Default font object for V-line labels
		//-----------------------------------------------------------------//
		var vLineLabelsFont = new StyleObject();
		vLineLabelsFont.name = "_SdDataVLineLabelsFont";
		vLineLabelsFont.align = "center";
		vLineLabelsFont.valign = "bottom";
		vLineLabelsFont.font = this.params.baseFont;
		vLineLabelsFont.size = this.params.baseFontSize;
		vLineLabelsFont.color = this.params.baseFontColor;
		vLineLabelsFont.bgcolor = this.params.canvasBgColor;
		//Over-ride
		this.styleM.overrideStyle(this.objects.VLINELABELS, vLineLabelsFont, this.styleM.TYPE.FONT, null);
		delete vLineLabelsFont;
		//-----------------------------------------------------------------//
		//Default Effect (Shadow) object for DataPlot
		//-----------------------------------------------------------------//
		if (this.params.showShadow) {
			var dataPlotShadow = new StyleObject();
			dataPlotShadow.name = "_SdDataPlotShadow";
			dataPlotShadow.distance = 3;
			dataPlotShadow.angle = 315;
			dataPlotShadow.alpha = 75;
			dataPlotShadow.color = "666666";
			dataPlotShadow.blurx = 8;
			dataPlotShadow.blury = 8;
			//Over-ride
			this.styleM.overrideStyle(this.objects.DATAPLOT, dataPlotShadow, this.styleM.TYPE.SHADOW, null);
			delete dataPlotShadow;
		}
		//-----------------------------------------------------------------// 
		//Default Effect (Shadow) object for Legend
		//-----------------------------------------------------------------//
		if (this.params.legendShadow) {
			var legendShadow = new StyleObject();
			legendShadow.name = "_SdLegendShadow";
			legendShadow.distance = 2;
			legendShadow.alpha = 90;
			legendShadow.angle = 45;
			//Over-ride
			this.styleM.overrideStyle(this.objects.LEGEND, legendShadow, this.styleM.TYPE.SHADOW, null);
			delete legendShadow;
		}
		//-----------------------------------------------------------------// 
		//Default Animation object for DataPlot (if required)
		//-----------------------------------------------------------------//
		if (this.params.defaultAnimation) {
			var dataPlotAnim = new StyleObject();
			dataPlotAnim.name = "_SdDataPlotAnim";
			dataPlotAnim.param = "_xscale";
			dataPlotAnim.easing = "regular";
			dataPlotAnim.wait = 0;
			dataPlotAnim.start = 0;
			dataPlotAnim.duration = 1;
			//Over-ride
			this.styleM.overrideStyle(this.objects.DATAPLOT, dataPlotAnim, this.styleM.TYPE.ANIMATION, "_xscale");
			delete dataPlotAnim;
		}
		//-----------------------------------------------------------------//		 
	}
	/**
	* calcVLinesPos method calculates the y position for the various
	* vLines defined. Also, it validates them.
	*/
	private function calcVLinesPos() {
		var i:Number;
		//Iterate through all the vLines
		for (i=1; i<=numVLines; i++) {
			//If the vLine is after 1st data and before last data
			if (this.vLines[i].index>0 && this.vLines[i].index<this.num) {
				//Set it's y position
				this.vLines[i].y = this.categories[this.vLines[i].index].y+(this.categories[this.vLines[i].index+1].y-this.categories[this.vLines[i].index].y)*this.vLines[i].linePosition;
			} else {
				//Invalidate it
				this.vLines[i].isValid = false;
			}
		}
	}
	/**
	* calculatePoints method calculates the various points on the chart.
	*/
	private function calculatePoints(isRedraw:Boolean) {
		//Loop variable
		var i:Number;
		var j:Number;
		//Feed empty data - By default there should be equal number of <categories>
		//and <set> element within each dataset. If in case, <set> elements fall short,
		//we need to append empty data at the end.
		for (i=1; i<=this.numDS; i++) {
			for (j=1; j<=this.num; j++) {
				if (this.dataset[i].data[j] == undefined) {
					this.dataset[i].data[j] = this.returnDataAsObject(NaN);
				}
			}
		}
		//Format all the numbers on the chart and store their display values
		//We format and store here itself, so that later, whenever needed,
		//we just access displayValue instead of formatting once again.
		//Also set tool tip text values
		var toolText:String;
		for (i=1; i<=this.numDS; i++) {
			for (j=1; j<=this.num; j++) {
				//Format and store
				this.dataset[i].data[j].displayValue = formatNumber(this.dataset[i].data[j].value, this.params.formatNumber, this.params.decimals, this.params.forceDecimals, this.params.formatNumberScale, this.params.defaultNumberScale, this.config.nsv, this.config.nsu, this.params.numberPrefix, this.params.numberSuffix, this.params.scaleRecursively, this.params.scaleSeparator, this.params.maxScaleRecursion);
				//Store formatted values
				this.dataset[i].data[j].formattedValue = this.dataset[i].data[j].displayValue;
				//Tool tip text.
				//Preferential Order - Set Tool Text (No concatenation) > SeriesName + Cat Name + Value
				if (this.dataset[i].data[j].toolText == undefined || this.dataset[i].data[j].toolText == "") {
					//If the tool tip text is not already defined
					//If labels have been defined
					toolText = (this.params.seriesNameInToolTip && this.dataset[i].seriesName != "") ? (this.dataset[i].seriesName+this.params.toolTipSepChar) : "";
					toolText = toolText+((this.categories[j].toolText != "") ? (this.categories[j].toolText+this.params.toolTipSepChar) : "");
					toolText = toolText+this.dataset[i].data[j].displayValue;
					this.dataset[i].data[j].toolText = toolText;
				}
				if (this.dataset[i].data[j].exDispVal != "") {
					this.dataset[i].data[j].displayValue = this.dataset[i].data[j].exDispVal;
				}
			}
		}
		//Based on label step, set showLabel of each data point as required.
		//Visible label count
		var visibleCount:Number = 0;
		var finalVisibleCount:Number = 0;
		for (i=1; i<=this.num; i++) {
			//Now, the label can be preset to be hidden (set via XML)
			if (this.categories[i].showLabel) {
				visibleCount++;
				//If label step is defined, we need to set showLabel of those
				//labels which fall on step as false.
				if ((i-1)%this.params.labelStep == 0) {
					this.categories[i].showLabel = true;
				} else {
					this.categories[i].showLabel = false;
				}
			}
			//Update counter 
			finalVisibleCount = (this.categories[i].showLabel && this.categories[i].label != "") ? (finalVisibleCount+1) : (finalVisibleCount);
		}
		//-----------------------------------------------------------------------------------//
		//Now, we need to calculate the available Height on the canvas.
		//Available height = total Chart height minus the list below
		// - Chart Top and Bottom Margins
		// - Space for Caption, Sub Caption and caption padding
		// - yAxisName (if to be shown)
		// - yAxisValues
		// - Trend line values
		//Initialize canvasHeight to total height minus margins
		var canvasHeight:Number = this.height-(this.params.chartTopMargin+this.params.chartBottomMargin);
		//Set canvasStartY
		var canvasStartY:Number = this.params.chartTopMargin;
		
		//Accomodate space for yAxisName (if to be shown); 
		if (this.params.yAxisName != "") {
			//Create text field to get height
			var yAxisNameObj:Object = createText(true, this.params.yAxisName, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle(this.objects.YAXISNAME), true, this.width-(this.params.chartLeftMargin+this.params.chartRightMargin), canvasHeight/2);
			//Store the height
			canvasHeight = canvasHeight-yAxisNameObj.height-this.params.yAxisNamePadding;
			//Object to store width and height of yAxisName
			this.elements.yAxisName = returnDataAsElement(0, 0, yAxisNameObj.width, yAxisNameObj.height);
			delete yAxisNameObj;
		}
		//Accomodate height for y-axis values. Now, y-axis values conists of two parts 
		//(for backward compatibility) - limits (upper and lower) and div line values.
		//So, we'll have to individually run through both of them.
		var yAxisValMaxHeight:Number = 0;
		var yAxisValMaxWidth:Number = 0;
		this.config.yValAreaHeight = 0;
		var divLineObj:Object;
		var divStyle:Object = this.styleM.getTextStyle(this.objects.YAXISVALUES);
		//Iterate through all the div line values
		for (i=1; i<this.divLines.length; i++) {
			//If div line value is to be shown
			if (this.divLines[i].showValue) {
				//If it's the first or last div Line (limits), and it's to be shown
				if ((i == 1) || (i == this.divLines.length-1)) {
					if (this.params.showLimits) {
						//Get the width of the text
						divLineObj = createText(true, this.divLines[i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, divStyle, false, 0, 0);
						//Accomodate
						yAxisValMaxWidth = (divLineObj.width>yAxisValMaxWidth) ? (divLineObj.width) : (yAxisValMaxWidth);
						yAxisValMaxHeight = (divLineObj.height>yAxisValMaxHeight) ? (divLineObj.height) : (yAxisValMaxHeight);
					}
				} else {
					//It's a div interval - div line
					//So, check if we've to show div line values
					if (this.params.showDivLineValues) {
						//Get the width of the text
						divLineObj = createText(true, this.divLines[i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, divStyle, false, 0, 0);
						//Accomodate
						yAxisValMaxWidth = (divLineObj.width>yAxisValMaxWidth) ? (divLineObj.width) : (yAxisValMaxWidth);
						yAxisValMaxHeight = (divLineObj.height>yAxisValMaxHeight) ? (divLineObj.height) : (yAxisValMaxHeight);
					}
				}
			}
		}
		//Accomodate
		if (yAxisValMaxHeight>0) {
			canvasHeight = canvasHeight-yAxisValMaxHeight-this.params.yAxisValuesPadding;
			//Store y-values height - will be used when we render trend-values later.
			this.config.yValAreaHeight = yAxisValMaxHeight+this.params.yAxisValuesPadding;
		}
		delete divLineObj;
		//Also iterate through all trend lines values
		var trendValHeight:Number = 0;
		this.config.trendValAreaHeight = 0;
		//Get style object		
		var trendStyle:Object = this.styleM.getTextStyle(this.objects.TRENDVALUES);
		var trendObj:Object;
		for (i=1; i<=this.numTrendLines; i++) {
			if (this.trendLines[i].isValid == true) {
				//If it's a valid trend line and value is to be shown on left
				//Get the width of the text
				trendObj = createText(true, this.trendLines[i].displayValue, this.tfTestMC, 1, testTFX, testTFY, 0, trendStyle, false, 0, 0);
				//Accomodate
				trendValHeight = (trendObj.height>trendValHeight) ? (trendObj.height) : (trendValHeight);
			}
		}
		//Accomodate
		if (trendValHeight>0) {
			canvasHeight = canvasHeight-trendValHeight-this.params.yAxisValuesPadding;
			//Store trend-values height - will be used when we render y-axis name later.
			this.config.trendValAreaHeight = trendValHeight+this.params.yAxisValuesPadding;
		}
		//We have canvas start Y and canvas height now		 
		//We now need to calculate the available Width on the canvas.
		//Available width = total Chart width minus the list below
		// - Left and Right Margin
		// - xAxisName (if to be shown)
		// - Data labels
		var canvasWidth:Number = this.width-(this.params.chartLeftMargin+this.params.chartRightMargin);
		//Set canvas startX
		var canvasStartX:Number = this.params.chartLeftMargin;
		//Now, if x-axis name is to be shown, simulate it and get the width
		if (this.params.xAxisName != "") {
			//Get style object
			var xAxisNameStyle:Object = this.styleM.getTextStyle(this.objects.XAXISNAME);
			if (this.params.rotateXAxisName) {
				//Create text field to get width
				var xAxisNameObj:Object = createText(true, this.params.xAxisName, this.tfTestMC, 1, testTFX, testTFY, 90, xAxisNameStyle, true, canvasHeight, canvasWidth/2);
				//Accomodate width and padding
				canvasStartX = canvasStartX+xAxisNameObj.width+this.params.xAxisNamePadding;
				canvasWidth = canvasWidth-xAxisNameObj.width-this.params.xAxisNamePadding;
				//Create element for xAxisName - to store width/height
				this.elements.xAxisName = returnDataAsElement(0, 0, xAxisNameObj.width, xAxisNameObj.height);
			} else {
				//If the x-axis name is not to be rotated
				//Calculate the width of the text if in full horizontal mode
				//Create text field to get width
				var xAxisNameObj:Object = createText(true, this.params.xAxisName, this.tfTestMC, 1, testTFX, testTFY, 0, xAxisNameStyle, false, 0, 0);
				//Get a value for this.params.xAxisNameWidth
				this.params.xAxisNameWidth = Number(getFV(this.params.xAxisNameWidth, xAxisNameObj.width));
				//Get the lesser of the width (to avoid un-necessary space)
				this.params.xAxisNameWidth = Math.min(this.params.xAxisNameWidth, xAxisNameObj.width);
				//Accomodate width and padding
				canvasStartX = canvasStartX+this.params.xAxisNameWidth+this.params.xAxisNamePadding;
				canvasWidth = canvasWidth-this.params.xAxisNameWidth-this.params.xAxisNamePadding;
				//Create element for xAxisName - to store width/height
				this.elements.xAxisName = returnDataAsElement(0, 0, this.params.xAxisNameWidth, xAxisNameObj.height);
			}
			delete xAxisNameStyle;
			delete xAxisNameObj;
		}
		
		//--------- Data label related calculations --------// 
		//Whether labels are to be wrapped?
		this.config.wrapLabels = true;
		//Max label width that can be alloted
		this.config.labelAreaWidth = 0;
		//Max label height that can be alloted
		this.config.labelAreaHeight = 0;
		//Now, if data labels are to be shown, we need to account for their width
		if (finalVisibleCount>0) {
			//Label creation object and style
			var labelObj:Object;
			var labelStyleObj:Object = this.styleM.getTextStyle(this.objects.DATALABELS);
			//Simulate a simple textfield without wrapping and store height
			//This is used to get the minimum height that can be allotted for a single
			//line view of label.
			labelObj = createText (true, "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&*():{}?><[];'", this.tfTestMC, 1, testTFX, testTFY, 0, labelStyleObj, false, 0, 0);
			//Store it.
			var noWrapHeight:Number = labelObj.height;
			//Run through all the labels and find maximum width required by them in single line
			var maxHorLabelWidth:Number = 0, maxHorLabelHeight:Number = 0;
			for (i = 1; i <= this.num; i++) {
				//If the label is to be shown
				if (this.categories [i].showLabel)
				{
					//Create text box with specified width and get height
					labelObj = createText (true, this.categories [i].label, this.tfTestMC, 1, testTFX, testTFY, 0, labelStyleObj, false, 0, 0);
					maxHorLabelWidth = Math.max(maxHorLabelWidth, labelObj.width);
					maxHorLabelHeight = Math.max(maxHorLabelHeight, labelObj.height);
				}
			}
			//Find maximum width (in pixels) that can be allotted to the labels
			var maxWidthAllocation:Number = (this.params.maxLabelWidthPercent/100)*canvasWidth;
			//If horizontal rendering of label is less than max width allocation, then we do not
			//need to wrap. So proceed futher
			if (maxHorLabelWidth<=maxWidthAllocation){
				this.config.labelAreaWidth = maxHorLabelWidth;
				this.config.labelAreaHeight = maxHorLabelHeight;
				this.config.wrapLabels = false;
				//Deduct the calculated label height from canvas height
				canvasStartX = canvasStartX + this.config.labelAreaWidth + this.params.labelPadding;
				canvasWidth = canvasWidth - this.config.labelAreaWidth - this.params.labelPadding;
			}else{
				//Placeholder to store max width
				var maxLabelWidth:Number = 0, simulatedLabelWidth:Number = 0;
				//Maximum height that we can dedicate per label - based on canvas height
				//and number of labels that we need to display. We assume equi-height labels
				//for the purpose of this calculation. Even if they're not, we restrict to
				//such a max height, that they never overlap.
				var maxHeightAllocation:Number = (canvasHeight*(1-(this.params.plotSpacePercent/100))) / finalVisibleCount;
				//Now, we start with an allocation of 5% of canvas width and see if 
				//all labels can fit into that width, without exceeding maxHeightAllocation
				//We end at this.params.maxLabelWidthPercent%, so that a small part of the chart is also visible.
				var startLabelWidthRatio:Number = 5, endLabelWidthRatio:Number = this.params.maxLabelWidthPercent;
				//Flag to store where re-calculation of scenario is required.
				var reloop:Boolean;
				//Now, simulate various width allocation and see what works.
				for (i=startLabelWidthRatio; i<=endLabelWidthRatio; i=i+5) {
					//Re-set reloop flag
					reloop = false;
					maxLabelWidth = 0;
					//Calculate the simulated width of the entire label area. We'll
					//try and fit all labels in this area and see what height they
					//need to assume.
					simulatedLabelWidth = (i/100)*canvasWidth;
					//Iterate through all the labels and check width
					for (j=1; j<=this.num; j++) {
						//If the label is to be shown
						if (this.categories[j].showLabel) {
							//Create text box with specified width and get height
							labelObj = createText(true, this.categories[j].label, this.tfTestMC, 1, testTFX, testTFY, 0, labelStyleObj, true, simulatedLabelWidth, canvasHeight);
							maxLabelWidth = Math.max(maxLabelWidth, labelObj.width);
							//If the height exceeds maxHeightAllocation, then we need to increase allocation
							//as it'll otherwise overlap. We also check whether the height is still over
							//the height required by a single line of unwrapped text (as that's the minimum
							//height required to render a text-field clearly).
							if (labelObj.overflow == true || (labelObj.height>maxHeightAllocation && labelObj.height>noWrapHeight)) {
								//The label needs more height than we could allocate, and it's still
								//in the safe zone of being more than the minimum no-wrap line.
								//So iterate again.
								reloop = true;
								break;
							}
						}
					}
					if (reloop == false) {
						//The optimum width % has been found. So store and break.
						this.config.labelAreaWidth = simulatedLabelWidth;
						this.config.labelAreaHeight = Math.max(noWrapHeight, maxHeightAllocation);
						break;
					}
				}
				//Even if after simulation, no result was found, then we force it to max value
				if (finalVisibleCount>0 && (this.config.labelAreaHeight == 0 || this.config.labelAreaWidth == 0)) {
					//Set max label width to maximum (this.params.maxLabelWidthPercent%)
					maxLabelWidth = (endLabelWidthRatio/100)*canvasWidth;
					//Store them.
					this.config.labelAreaWidth = maxLabelWidth;
					//Assume height of a simple no-wrap textfield for a miminal display
					//Due to wrapping, the rest of text will be automatically trimmed off.
					this.config.labelAreaHeight = Math.max(noWrapHeight, maxHeightAllocation);
				}				
				//Deduct from canvas
				if (this.config.labelAreaWidth>0) {
					this.config.labelAreaWidth = maxLabelWidth;
					//Deduct the calculated label height from canvas height
					canvasStartX = canvasStartX+this.config.labelAreaWidth+this.params.labelPadding;
					canvasWidth = canvasWidth-this.config.labelAreaWidth-this.params.labelPadding;
				}
			}
			//Delete objects 
			delete labelObj;
			delete labelStyleObj;
		}
		//We have canvas start Y and canvas height 
		//We now check whether the legend is to be drawn
		if (this.params.showLegend) {
			//Object to store dimensions
			var lgndDim:Object;
			//MC removed if present before recreation of the MC
			if(this.lgndMC){
				this.lgndMC.removeMovieClip();
			}
			//Create container movie clip for legend 
			this.lgndMC = this.cMC.createEmptyMovieClip("Legend", this.dm.getDepth("LEGEND"));
			//When clickURL exist legend interactivity should  false
			this.params.interactiveLegend = (this.params.interactiveLegend  && (this.params.clickURL == "" || this.params.clickURL == null || this.params.clickURL == undefined ))?  true : false;
			//Create instance of legend
			if (this.params.legendPosition == "BOTTOM") {
				//Maximum Height - 50% of stage
				lgnd = new AdvancedLegend(lgndMC, this.styleM.getTextStyle(this.objects.LEGEND), this.params.interactiveLegend, this.params.legendPosition, canvasStartX+canvasWidth/2, this.height/2, canvasWidth, (this.height-(this.params.chartTopMargin+this.params.chartBottomMargin))*0.5, this.params.legendAllowDrag, this.width, this.height, this.params.legendBgColor, this.params.legendBgAlpha, this.params.legendBorderColor, this.params.legendBorderThickness, this.params.legendBorderAlpha, this.params.legendScrollBgColor, this.params.legendScrollBarColor, this.params.legendScrollBtnColor, this.params.legendNumColumns);
			} else {
				//Maximum Width - 40% of stage
				lgnd = new AdvancedLegend(lgndMC, this.styleM.getTextStyle(this.objects.LEGEND), this.params.interactiveLegend, this.params.legendPosition, this.width/2, canvasStartY+canvasHeight/2, (this.width-(this.params.chartLeftMargin+this.params.chartRightMargin))*0.4, canvasHeight, this.params.legendAllowDrag, this.width, this.height, this.params.legendBgColor, this.params.legendBgAlpha, this.params.legendBorderColor, this.params.legendBorderThickness, this.params.legendBorderAlpha, this.params.legendScrollBgColor, this.params.legendScrollBarColor, this.params.legendScrollBtnColor, this.params.legendNumColumns);
			}
			if (this.params.minimiseWrappingInLegend) {
				lgnd.minimiseWrapping = true;
			}
			//Get the height of single line text for legend items (to be used to specify icon width and height)
			var iconHeight:Number = lgnd.getIconHeight()*this.params.legendIconScale;
			var j:Number;
			var objIcon:Object;
			for (i=1; i<=this.numDS; i++) {
				//Adjust working index for reverseLegend option
				j = (this.params.reverseLegend) ? this.numDS-i+1 : i;
				//Validation of item eligibility
				if (this.dataset[j].includeInLegend && this.dataset[j].seriesName != "") {
					objIcon = {fillColor:parseInt(this.dataset[j].color, 16), intraIconPaddingPercent:0.3};
					//Create the 2 icons
					var objIcons:Object = LegendIconGenerator.getIcons(LegendIconGenerator.BAR, iconHeight, true, objIcon);
					//State specific icon BitmapData
					var bmpd1:BitmapData = objIcons.active;
					var bmpd2:BitmapData = objIcons.inactive;
					//Add the item to legend
					lgnd.addItem(this.dataset[j].seriesName, j, true, bmpd1, bmpd2);
				}
			}
			//If user has defined a caption for the legend, set it
			if (this.params.legendCaption != "") {
				lgnd.setCaption(this.params.legendCaption);
			}
			if (this.params.legendPosition == "BOTTOM") {
				lgndDim = lgnd.getDimensions();
				//Now deduct the height from the calculated canvas height
				canvasHeight = canvasHeight-lgndDim.height-this.params.legendPadding;
				//Re-set the legend position
				this.lgnd.resetXY(canvasStartX+canvasWidth/2, this.height-this.params.chartBottomMargin-lgndDim.height/2);
			} else {
				//Get dimensions
				lgndDim = lgnd.getDimensions();
				//Now deduct the width from the calculated canvas width
				canvasWidth = canvasWidth-lgndDim.width-this.params.legendPadding;
				//Right position
				this.lgnd.resetXY(this.width-this.params.chartRightMargin-lgndDim.width/2, canvasStartY+canvasHeight/2);
			}
		}
		//Legend Area height for xAxisName  y position calculation
		this.config.legendAreaHeight = (this.params.showLegend && this.params.legendPosition == "BOTTOM" && this.lgnd.items.length > 0)? (lgndDim.height + this.params.legendPadding) : 0;
		//----------- HANDLING CUSTOM CANVAS MARGINS --------------// 
		//Before doing so, we take into consideration, user's forced canvas margins (if any defined)
		//If the user's forced values result in overlapping of chart items, we ignore.
		if (this.params.canvasLeftMargin != -1 && this.params.canvasLeftMargin>canvasStartX) {
			//Update width (deduct the difference)
			canvasWidth = canvasWidth-(this.params.canvasLeftMargin-canvasStartX);
			//Update left start position
			canvasStartX = this.params.canvasLeftMargin;
		}
		if (this.params.canvasRightMargin != -1 && (this.params.canvasRightMargin>(this.width-(canvasStartX+canvasWidth)))) {
			//Update width (deduct the difference)
			canvasWidth = canvasWidth-(this.params.canvasRightMargin-(this.width-(canvasStartX+canvasWidth)));
		}
		if (this.params.canvasTopMargin != -1 && this.params.canvasTopMargin>canvasStartY) {
			//Update height (deduct the difference)
			canvasHeight = canvasHeight-(this.params.canvasTopMargin-canvasStartY);
			//Update top start position
			canvasStartY = this.params.canvasTopMargin;
		}
		if (this.params.canvasBottomMargin != -1 && (this.params.canvasBottomMargin>(this.height-(canvasStartY+canvasHeight)))) {
			//Update height(deduct the difference)
			canvasHeight = canvasHeight-(this.params.canvasBottomMargin-(this.height-(canvasStartY+canvasHeight)));
		}
		//------------ END OF CUSTOM CANVAS MARGIN HANDLING --------------------// 
		//----------------- Caption and Subcaption Handling---------------------//
		//Now, if we've to show caption
		if (this.params.caption != "") {
			//Create text field to get height
			var captionObj:Object = createText(true, this.params.caption, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle(this.objects.CAPTION), true, canvasWidth, this.height/4);
			//Store the height
			canvasStartY = canvasStartY+captionObj.height;
			canvasHeight = canvasHeight-captionObj.height;
			//Create element for caption - to store width & height
			this.elements.caption = returnDataAsElement(0, 0, captionObj.width, captionObj.height);
			delete captionObj;
		}
		//Now, if we've to show sub-caption 
		if (this.params.subCaption != "") {
			//Create text field to get height
			var subCaptionObj:Object = createText(true, this.params.subCaption, this.tfTestMC, 1, testTFX, testTFY, 0, this.styleM.getTextStyle(this.objects.SUBCAPTION), true, canvasWidth, this.height/4);
			//Store the height
			canvasStartY = canvasStartY+subCaptionObj.height;
			canvasHeight = canvasHeight-subCaptionObj.height;
			//Create element for sub caption - to store height
			this.elements.subCaption = returnDataAsElement(0, 0, subCaptionObj.width, subCaptionObj.height);
			delete subCaptionObj;
		}
		//Now, if either caption or sub-caption was shown, we also need to adjust caption padding 
		if (this.params.caption != "" || this.params.subCaption != "") {
			//Account for padding
			canvasStartY = canvasStartY+this.params.captionPadding;
			canvasHeight = canvasHeight-this.params.captionPadding;
		}
		//----------------- End of Caption and Subcaption Handling------------//
		//Create an element to represent the canvas now.
		this.elements.canvas = returnDataAsElement(canvasStartX, canvasStartY, canvasWidth, canvasHeight);
		//Now, we have the size for the entire chart canvas
		//The canvas comprises of two things - canvas background and canvas base
		//The width and slant height of canvas base depends on the number of bars and height (depth) of each bar
		//Now, we will calculate the space to be alloted to the canvasBg and canvasBase
		//First, depending on the number of bars, calculate the height of each bar.
		var barHeight:Number = ((this.elements.canvas.h-this.params.canvasBgDepth-2*this.params.canvasPadding)*((100-this.params.plotSpacePercent)/100))/(this.num*this.numDS);
		//Set the flag for overlapBars based on bar height
		//We overlap bars only if the bar height < this.params.maxBarHeight
		var overlapBars:Number = (barHeight<this.params.maxBarHeight) ? 1 : 0;
		this.params.overlapBars = toBoolean(getFN(this.params.overlapBars, overlapBars));
		//If overlap is false or num bars==1, we check against max height of bars
		if (!this.params.overlapBars || this.numDS*this.num == 1) {
			barHeight = (barHeight > this.params.maxBarHeight && this.defaultPlotSpacePercent) ? this.params.maxBarHeight : barHeight;
		}
		//Calculate and store the shifts 
		this.config.shifts = Bar3D.calcShifts(barHeight, 45, this.params.barDepth);
		//Get block height and store a copy of bar Width as oBarHeight
		//(as we'll later tweak oBarHeight for overlap).
		var blockHeight:Number = barHeight*this.numDS;
		var oBarHeight:Number = barHeight;
		//Now, if we've to overlap bars (with number of bars in a dataset >1)
		//we need to re-calculate bar height
		if (this.params.overlapBars && this.numDS>1) {
			//Get the maximum possible y-space that the shadow of all bars in a block can take.
			var totalShadow:Number = (this.config.shifts.hShadow)*(this.numDS);
			//Do a conditional check to alter total shadow space
			if (this.config.shifts.hShadow>=this.config.shifts.hFront) {
				//If the bars are high depth bars.
				totalShadow = totalShadow*(this.config.shifts.hFront/this.config.shifts.hShadow);
			} else {
				//Low depth bars - more height on front side.
				totalShadow = totalShadow*0.75;
			}
			//Get new bar height based on the above calculated figures
			barHeight = ((barHeight*this.numDS)+(totalShadow*0.5))/(this.numDS);
			//Re-calculate the bar 3D Shifts
			this.config.shifts = Bar3D.calcShifts(barHeight, 45, this.params.barDepth);
		}
		//For 3D look the bar shifts need always same irrespective of how much thiner the bar is.
		this.config.shifts.yShift =  (this.config.shifts.yShift < 7)? 7 : this.config.shifts.yShift;
		this.config.shifts.xShift =  (this.config.shifts.xShift < 7)? 7 : this.config.shifts.xShift;
		//Now, store canvas base and canvas bg as elements of chart 
		this.elements.canvasBg = returnDataAsElement(this.elements.canvas.x+this.params.canvasBaseDepth+this.config.shifts.xShift, this.elements.canvas.y+this.params.canvasBgDepth, this.elements.canvas.w-this.params.canvasBaseDepth-this.config.shifts.xShift, this.elements.canvas.h-this.params.canvasBgDepth-((this.config.zeroPRequired == true) ? this.config.shifts.yShift : 0));
		this.elements.canvasBase = returnDataAsElement(this.elements.canvas.x+this.params.canvasBaseDepth, this.elements.canvasBg.y+this.config.shifts.yShift, this.config.shifts.xShift, this.elements.canvasBg.h);
		//Based on canvas width that has been calculated, re-adjust yaxisLabelStep
		this.adjustYAxisLabelStep(yAxisValMaxWidth, this.elements.canvasBg.w);
		//Base Plane position - Base plane is the y-plane from which bars start.
		//If there's a 0 value in between yMin,yMax, base plane represents 0 value.
		//Else, it's yMin
		if (this.config.yMax>=0 && this.config.yMin<0) {
			//Negative number present - so set basePlanePos as 0 value
			this.config.basePlanePos = this.getAxisPosition(0, this.config.yMax, this.config.yMin, this.elements.canvasBg.x, this.elements.canvasBg.toX, false, 0);
		} else if (this.config.yMax < 0 && this.config.yMin < 0)
		{
			// All Negative number present - so set basePlanePos as Max value
			this.config.basePlanePos = this.getAxisPosition(this.config.yMax, this.config.yMax, this.config.yMin, this.elements.canvasBg.x, this.elements.canvasBg.toX, false, 0);
		} else {
			//No negative numbers - so set basePlanePos as yMin value
			this.config.basePlanePos = this.getAxisPosition(this.config.yMin, this.config.yMax, this.config.yMin, this.elements.canvasBg.x, this.elements.canvasBg.toX, false, 0);
		}
		//Calculate space between two bar blocks
		var blockSpace:Number = ((this.elements.canvasBg.h-2*this.params.canvasPadding)-(blockHeight*this.num))/(this.num+1);

		//We finally have block height and space
		//Store it in config
		this.config.barHeight = barHeight;
		this.config.blockSpace = blockSpace;
		//We now need to calculate the position of bars on the chart.
		var dataEndX:Number;
		var shadowH:Number;
		
		//Now, store the positions of the bars
		for (i=1; i<=this.num; i++) {
			//Store position of categories
			this.categories[i].y = this.elements.canvasBg.y+this.params.canvasPadding+(blockSpace*i)+(blockHeight*(i-0.5))+this.config.shifts.yShift;

			for (j=1; j<=this.numDS; j++) {
				//y-Position of bars
				this.dataset[j].data[i].y = this.elements.canvasBg.y+this.params.canvasPadding+(blockSpace*i)+(blockHeight*(i-1))+(oBarHeight*(j-0.5))+this.config.shifts.yShift;
				//Set the x position
				this.dataset[j].data[i].x = this.config.basePlanePos-this.config.shifts.xShift;
				//Width for each bar
				dataEndX = this.getAxisPosition(this.dataset[j].data[i].value, this.config.yMax, this.config.yMin, this.elements.canvasBg.x, this.elements.canvasBg.toX, false, 0);
				//Negate to cancel Flash's reverse Y Co-ordinate system
				this.dataset[j].data[i].w = (dataEndX-this.config.basePlanePos);
				//Height
				//Due to column shadow, especially for 3D looks the gap between two bars in same block is needed. The gap is minimized on very small plotspacepercent.
				shadowH = (this.config.shifts.hShadow*0.75)*((this.params.plotSpacePercent < 5)? (this.params.plotSpacePercent/10): 1);
				shadowH = (shadowH > (barHeight*0.5))? (barHeight*0.5): shadowH;
				this.dataset[j].data[i].h = barHeight - shadowH;
				//Store value textbox x position
				this.dataset[j].data[i].valTBX = dataEndX;
			}
		}
	}
	/**
	* allotDepths method allots the depths for various chart objects
	* to be rendered. We do this before hand, so that we can later just
	* go on rendering chart objects, without swapping.
	*/
	private function allotDepths():Void {
		//Background
		this.dm.reserveDepths("BACKGROUND", 1);
		//Click URL Handler
		this.dm.reserveDepths("CLICKURLHANDLER", 1);
		//Background SWF
		this.dm.reserveDepths("BGSWF", 1);
		//Canvas
		this.dm.reserveDepths("CANVASBG", 1);
		this.dm.reserveDepths("CANVASBASE", 1);
		//Div Lines and their labels
		this.dm.reserveDepths("DIVLINES", (this.divLines.length*2));
		//Caption
		this.dm.reserveDepths("CAPTION", 1);
		//Sub-caption
		this.dm.reserveDepths("SUBCAPTION", 1);
		//X-Axis Name
		this.dm.reserveDepths("XAXISNAME", 1);
		//Y-Axis Name
		this.dm.reserveDepths("YAXISNAME", 1);
		//Trend lines plot (lines and their labels)
		this.dm.reserveDepths("TRENDLINES", this.numTrendLines);
		this.dm.reserveDepths("TRENDVALUES", this.numTrendLines);
		//Vertical div lines
		this.dm.reserveDepths("VLINES", this.numVLines);
		//Vertical div lines labels
		this.dm.reserveDepths("VLINELABELS", this.numVLines);
		//Data Labels
		this.dm.reserveDepths("DATALABELS", this.num);
		//Data Bars - Negative values
		this.dm.reserveDepths("DATAPLOTNEG", this.numNeg);
		//Zero Plane
		this.dm.reserveDepths("ZEROPLANE", 2);
		//Data Bars - Positive Values
		this.dm.reserveDepths("DATAPLOTPOS", this.numPos);
		//Data Values
		this.dm.reserveDepths("DATAVALUES", this.num*this.numDS);
		//Legend
		this.dm.reserveDepths("LEGEND", 1);
	}
	//--------------- VISUAL RENDERING METHODS -------------------------//
	/**
	* drawHeaders method renders the following on the chart:
	* CAPTION, SUBCAPTION, XAXISNAME, YAXISNAME
	*/
	private function drawHeaders() {
		//Render caption
		if (this.params.caption != "") {
			var captionStyleObj:Object = this.styleM.getTextStyle(this.objects.CAPTION);
			captionStyleObj.vAlign = "bottom";
			//Switch the alignment to lower case
			captionStyleObj.align = captionStyleObj.align.toLowerCase();
			//Now, based on alignment, decide the xPosition of the caption
			var xPos:Number = (captionStyleObj.align=="center")?(this.elements.canvas.x + (this.elements.canvas.w / 2)):((captionStyleObj.align=="left")?(this.elements.canvas.x):(this.elements.canvas.toX));
			var captionObj:Object = createText(false, this.params.caption, this.cMC, this.dm.getDepth("CAPTION"), xPos, this.params.chartTopMargin, 0, captionStyleObj, true, this.elements.caption.w, this.elements.caption.h);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(captionObj.tf, this.objects.CAPTION, this.macro, captionObj.tf._x, 0, captionObj.tf._y, 0, 100, null, null, null);
			}
			//Apply filters 
			this.styleM.applyFilters(captionObj.tf, this.objects.CAPTION);
			//Delete
			delete captionObj;
			delete captionStyleObj;
		}
		//Render sub caption 
		if (this.params.subCaption != "") {
			var subCaptionStyleObj:Object = this.styleM.getTextStyle(this.objects.SUBCAPTION);
			subCaptionStyleObj.vAlign = "top";
			//Switch the alignment to lower case
			subCaptionStyleObj.align = subCaptionStyleObj.align.toLowerCase();
			//Now, based on alignment, decide the xPosition of the caption
			var xPos:Number = (subCaptionStyleObj.align=="center")?(this.elements.canvas.x + (this.elements.canvas.w / 2)):((subCaptionStyleObj.align=="left")?(this.elements.canvas.x):(this.elements.canvas.toX));
			var subCaptionObj:Object = createText(false, this.params.subCaption, this.cMC, this.dm.getDepth("SUBCAPTION"), xPos, this.elements.canvas.y-this.params.captionPadding, 0, subCaptionStyleObj, true, this.elements.subCaption.w, this.elements.subCaption.h);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(subCaptionObj.tf, this.objects.SUBCAPTION, this.macro, subCaptionObj.tf._x, 0, subCaptionObj.tf._y, 0, 100, null, null, null);
			}
			//Apply filters 
			this.styleM.applyFilters(subCaptionObj.tf, this.objects.SUBCAPTION);
			//Delete
			delete subCaptionObj;
			delete subCaptionStyleObj;
		}
		//Render y-axis name 
		if (this.params.yAxisName != "") {
			var yAxisNameStyleObj:Object = this.styleM.getTextStyle(this.objects.YAXISNAME);
			yAxisNameStyleObj.align = "center";
			yAxisNameStyleObj.vAlign = "bottom";
			var yAxisNameObj:Object = createText(false, this.params.yAxisName, this.cMC, this.dm.getDepth("YAXISNAME"), this.width/2, this.height -(this.params.chartBottomMargin + this.config.legendAreaHeight + this.elements.yAxisName.h + this.params.yAxisNamePadding), 0, yAxisNameStyleObj, true, this.width-(this.params.chartLeftMargin+this.params.chartRightMargin), this.elements.yAxisName.h);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(yAxisNameObj.tf, this.objects.YAXISNAME, this.macro, yAxisNameObj.tf._x, 0, yAxisNameObj.tf._y, 0, 100, null, null, null);
			}
			//Apply filters 
			this.styleM.applyFilters(yAxisNameObj.tf, this.objects.YAXISNAME);
			//Delete
			delete yAxisNameObj;
			delete yAxisNameStyleObj;
		}
		//Render x-axis name 
		if (this.params.xAxisName != "") {
			var xAxisNameStyleObj:Object = this.styleM.getTextStyle(this.objects.XAXISNAME);
			//Set alignment parameters
			xAxisNameStyleObj.align = "left";
			xAxisNameStyleObj.vAlign = "middle";
			//If the name is to be rotated
			if (this.params.rotateXAxisName) {
				if(this.params.centerXAxisName){
					//Center x axis name with respect to chart.
					var xAxisNameObj : Object = createText (false, this.params.xAxisName, this.cMC, this.dm.getDepth ("XAXISNAME") , this.params.chartLeftMargin, this.height/2, 270, xAxisNameStyleObj, true, this.elements.xAxisName.h, this.elements.xAxisName.w);
				}else{
					//Center x axis name with respect to canvas.
					var xAxisNameObj : Object = createText (false, this.params.xAxisName, this.cMC, this.dm.getDepth ("XAXISNAME") , this.params.chartLeftMargin, this.elements.canvas.y + (this.elements.canvas.h / 2) , 270, xAxisNameStyleObj, true, this.elements.xAxisName.h, this.elements.xAxisName.w);
				}
				//Apply animation
				if (this.params.animation) {
					this.styleM.applyAnimation(xAxisNameObj.tf, this.objects.XAXISNAME, this.macro, xAxisNameObj.tf._x, 0, xAxisNameObj.tf._y, 0, 100, null, null, null);
				}
			} else {
				//We show horizontal name
				//Adding 1 to this.params.xAxisNameWidth and then passing to avoid line breaks
				var xAxisNameObj:Object = createText(false, this.params.xAxisName, this.cMC, this.dm.getDepth("XAXISNAME"), this.params.chartLeftMargin, this.elements.canvasBase.y+(this.elements.canvasBase.h/2), 0, xAxisNameStyleObj, true, this.params.xAxisNameWidth+1, this.elements.canvasBase.h);
				//Apply animation
				if (this.params.animation) {
					this.styleM.applyAnimation(xAxisNameObj.tf, this.objects.XAXISNAME, this.macro, xAxisNameObj.tf._x, 0, xAxisNameObj.tf._y, 0, 100, null, null, null);
				}
			}
			//Apply filters
			this.styleM.applyFilters(xAxisNameObj.tf, this.objects.XAXISNAME);
			//Delete
			delete xAxisNameObj;
			delete xAxisNameStyleObj;
		}
		//Clear Interval 
		clearInterval(this.config.intervals.headers);
	}
	/**
	* drawLabels method draws the x-axis labels based on the oarameters.
	*/
	private function drawLabels() {
		var labelObj:Object;
		var labelStyleObj:Object = this.styleM.getTextStyle(this.objects.DATALABELS);
		var depth:Number = this.dm.getDepth("DATALABELS");
		var i:Number;
		for (i=1; i<=this.num; i++) {
			//If the label is to be shown
			if (this.categories[i].showLabel) {
				//Render normal label
				labelStyleObj.align = "right";
				labelStyleObj.vAlign = "middle";
				labelObj = createText(false, this.categories[i].label, this.cMC, depth, this.elements.canvas.x-this.params.labelPadding, this.categories[i].y, 0, labelStyleObj, this.config.wrapLabels, this.config.labelAreaWidth, this.config.labelAreaHeight);
				//Apply filter
				this.styleM.applyFilters(labelObj.tf, this.objects.DATALABELS);
				//Apply animation
				if (this.params.animation) {
					this.styleM.applyAnimation(labelObj.tf, this.objects.DATALABELS, this.macro, labelObj.tf._x, 0, labelObj.tf._y, 0, 100, null, null, null);
				}
				//Increase depth 
				depth++;
			}
		}
		//Clear interval
		clearInterval(this.config.intervals.labels);
	}
	/**
	* drawBars method draws the bars on the chart
	*/
	private function drawBars() {
		//Variables
		var barMC:MovieClip;
		var barIns:Bar3D;
		var posDepth:Number = this.dm.getDepth("DATAPLOTPOS");
		var negDepth:Number = this.dm.getDepth("DATAPLOTNEG");
		var depth:Number;
		var i:Number;
		var j:Number;
		var animX:Number;
		//Create function storage containers for Delegate functions
		var fnRollOver:Function, fnClick:Function;
		//Iterate through all bars
		//Using reverse loop for automatic depth iteration
		for (i=this.num; i>=1; i--) {
			for (j=this.numDS; j>=1; j--) {
				//If defined
				if (this.dataset[j].data[i].isDefined) {
					//Get depth based on whether the bar is positive or negative
					if (this.dataset[j].data[i].value<0) {
						depth = negDepth;
						negDepth++;
					} else {
						depth = posDepth;
						posDepth++;
					}
					//Create an empty movie clip for this bar
					barMC = this.cMC.createEmptyMovieClip("Bar_"+i+"_"+j, depth);
					//Register with object Manager
					objM.register(barMC, "DATAPLOT_"+j+"_"+i, "DATAPLOTS_"+j);
					//Create bar instance
					barIns = new Bar3D(barMC, this.dataset[j].data[i].x, this.dataset[j].data[i].y, this.dataset[j].data[i].w, this.dataset[j].data[i].h, this.config.shifts.xShift, this.config.shifts.yShift, this.dataset[j].data[i].color, this.params.showPlotBorder, this.params.plotBorderColor, this.params.plotBorderAlpha);
					//Draw the bar
					barIns.draw(this.params.use3DLighting);
					//Set the alpha of entire bar
					barMC._alpha = this.dataset[j].data[i].alpha;
					//Apply animation
					if (this.params.animation) {
						//We animate xScale only if |width| > this.config.shifts.xShift*1.5
						if (Math.abs(this.dataset[j].data[i].w)>(this.config.shifts.xShift*1.5)) {
							animX = 100;
						} else {
							animX = null;
						}
						this.styleM.applyAnimation(barMC, this.objects.DATAPLOT, this.macro, this.dataset[j].data[i].x, 0, this.dataset[j].data[i].y, 0, 100, animX, 100, null);
					}
					//Apply filters 
					this.styleM.applyFilters(barMC, this.objects.DATAPLOT);
					//Event handlers for tool tip
					if (this.params.showToolTip) {
						//Create Delegate for roll over function barOnRollOver
						fnRollOver = Delegate.create(this, barOnRollOver);
						//Set the index
						fnRollOver.dsindex = j;
						fnRollOver.index = i;
						//Assing the delegates to movie clip handler
						barMC.onRollOver = fnRollOver;
						//Set roll out and mouse move too.
						barMC.onRollOut = barMC.onReleaseOutside=Delegate.create(this, barOnRollOut);
						barMC.onMouseMove = Delegate.create(this, barOnMouseMove);
					}
					//Click handler for links - only if link for this bar has been defined and click URL 
					//has not been defined.
					if (this.dataset[j].data[i].link != "" && this.dataset[j].data[i].link != undefined && this.params.clickURL == "") {
						//Create delegate function
						fnClick = Delegate.create(this, barOnClick);
						//Set index
						fnClick.dsindex = j;
						fnClick.index = i;
						//Assign
						barMC.onRelease = fnClick;
					} else {
						//Do not use hand cursor
						barMC.useHandCursor = (this.params.clickURL == "") ? false : true;
						//Enable for clickURL
						this.invokeClickURLFromPlots(barMC);
					}
				}
			}
		}
		//Clear interval
		clearInterval(this.config.intervals.plot);
	}
	/**
	* drawValues method draws the values on the chart.
	*/
	private function drawValues():Void {
		//Get value text style
		var valueStyleObj:Object = this.styleM.getTextStyle(this.objects.DATAVALUES);
		//Container object
		var valueObj:MovieClip;
		//Depth
		var depth:Number = this.dm.getDepth("DATAVALUES");
		//Loop var
		var i:Number;
		var j:Number;
		var xPos:Number;
		var yPos:Number;
		var align:String, vAlign:String;
		////Iterate through all bars
		for (i=1; i<=this.numDS; i++) {
			for (j=1; j<=this.num; j++) {
				//If defined and value is to be shown
				if (this.dataset[i].data[j].isDefined && this.dataset[i].data[j].showValue) {
					//Get the x position based on placeValuesInside and bar height
					if (this.params.placeValuesInside) {
						//Alignment position of the value box
						align = (this.dataset[i].data[j].w>=0) ? "right" : "left";
						xPos = (this.dataset[i].data[j].w>=0) ? (this.dataset[i].data[j].valTBX-this.params.valuePadding-this.config.shifts.xShift) : (this.dataset[i].data[j].valTBX+this.params.valuePadding-this.config.shifts.xShift);
					} else {
						align = (this.dataset[i].data[j].w>=0) ? "left" : "right";
						xPos = (this.dataset[i].data[j].w>=0) ? (this.dataset[i].data[j].valTBX+this.params.valuePadding) : (this.dataset[i].data[j].valTBX-this.params.valuePadding-this.config.shifts.xShift);
					}
					if (this.params.placeValuesInside) {
						yPos = this.dataset[i].data[j].y;
					} else {
						yPos = (this.dataset[i].data[j].value<0) ? (this.dataset[i].data[j].y) : (this.dataset[i].data[j].y-this.config.shifts.yShift);
					}
					//V-Align position
					vAlign = "middle";
					//Convey alignment to rendering object
					valueStyleObj.align = align;
					valueStyleObj.vAlign = vAlign;
					valueObj = createText(false, this.dataset[i].data[j].displayValue, this.cMC, depth, xPos, yPos, 0, valueStyleObj, false, 0, 0);
					//Now, we need to adjust those labels which are falling out of width of bar.
					if (this.params.placeValuesInside && ((this.params.valuePadding+valueObj.width)>=Math.abs(this.dataset[i].data[j].w))) {
						//If the values are to be placed inside bar, but the width of the bar
						//is less than the width of textbox (+ padding), we show the textbox to the left/right of bar
						//For positive bar
						if (this.dataset[i].data[j].w>=0) {
							//Show on the right
							valueObj.tf._x = this.dataset[i].data[j].x+this.config.shifts.yShift+this.dataset[i].data[j].w+this.params.valuePadding;
							valueObj.tf._y = valueObj.tf._y-this.config.shifts.yShift;
						} else {
							//Negative Bar - show to the left							
							valueObj.tf._x = this.dataset[i].data[j].x-Math.abs(this.dataset[i].data[j].w)-this.params.valuePadding-valueObj.tf._width;
						}
					}
					//Next, we adjust those labels are falling out of right canvas area 
					//For Positive bars only
					if ((!this.params.placeValuesInside) && (this.dataset[i].data[j].w>=0) && ((xPos+valueObj.width)>=this.elements.canvasBg.toX)) {
						//Data value is colliding with the right side of canvas. So we need to place it within
						//the bar
						valueObj.tf._x = xPos-(2*this.params.valuePadding)-this.config.shifts.xShift-valueObj.width;
						valueObj.tf._y = valueObj.tf._y+this.config.shifts.yShift;
					}
					//Now, we adjust those labels are falling out of left canvas area 
					//For Negative Bars Only
					if ((!this.params.placeValuesInside) && (this.dataset[i].data[j].w<0) && ((xPos-valueObj.width)<=this.elements.canvasBg.x)) {
						//Data value is colliding with the left side of canvas. So we need to place it within
						//the bar
						valueObj.tf._x = xPos+(2*this.params.valuePadding);
					}
					//For values that are overlapping finally with the canvas (left side) or data labels, hide them 
					if (valueObj.tf._x<=this.elements.canvasBg.x) {
						valueObj.tf.removeTextField();
					}
					//Register with object Manager 
					objM.register(valueObj.tf, "DATAVALUE_"+i+"_"+j, "DATAVALUES_"+i);
					//Apply filter
					this.styleM.applyFilters(valueObj.tf, this.objects.DATAVALUES);
					//Apply animation
					if (this.params.animation) {
						this.styleM.applyAnimation(valueObj.tf, this.objects.DATAVALUES, this.macro, valueObj.tf._x, 0, valueObj.tf._y, 0, 100, null, null, null);
					}
					//Increase depth 
					depth++;
				}
			}
		}
		//Clear interval
		clearInterval(this.config.intervals.dataValues);
	}
	/**
	* drawLegend method renders the legend
	*/
	private function drawLegend():Void {
		if (this.params.showLegend) {
			this.lgnd.render();
			//If it's interactive legend, listen to events
			if (this.params.interactiveLegend) {
				this.lgnd.addEventListener("legendClick", this);
			}
			//Apply filter 
			this.styleM.applyFilters(lgndMC, this.objects.LEGEND);
			//Apply animation
			if (this.params.animation) {
				this.styleM.applyAnimation(lgndMC, this.objects.LEGEND, this.macro, null, 0, null, 0, 100, null, null, null);
			}
		}
		//Clear interval 
		clearInterval(this.config.intervals.legend);
	}
	/**
	* setContextMenu method sets the context menu for the chart.
	* For this chart, the context items are "Print Chart".
	*/
	private function setContextMenu():Void {
		var chartMenu:ContextMenu = new ContextMenu();
		chartMenu.hideBuiltInItems();
		if (this.params.showPrintMenuItem) {
			//Create a print chart contenxt menu item
			var printCMI:ContextMenuItem = new ContextMenuItem("Print Chart", Delegate.create(this, printChart));
			//Push print item.
			chartMenu.customItems.push(printCMI);
		}
		//If the export data item is to be shown 
		if (this.params.showExportDataMenuItem) {
			chartMenu.customItems.push(super.returnExportDataMenuItem());
		}
		//Add export chart related menu items to the context menu 
		this.addExportItemsToMenu(chartMenu);
		if (this.params.showFCMenuItem) {
			//Push "About FusionCharts" Menu Item
			chartMenu.customItems.push(super.returnAbtMenuItem());
		}
		//Assign the menu to cMC movie clip 
		this.cMC.menu = chartMenu;
	}
	// -------------------- EVENT HANDLERS --------------------//
	/**
	* barOnRollOver is the delegat-ed event handler method that'll
	* be invoked when the user rolls his mouse over a bar.
	* This function is invoked, only if the tool tip is to be shown.
	* Here, we show the tool tip.
	*/
	private function barOnRollOver():Void {
		//Index of bar is stored in arguments.caller.index
		var dsindex:Number = arguments.caller.dsindex;
		var index:Number = arguments.caller.index;
		//Set tool tip text
		this.tTip.setText(this.dataset[dsindex].data[index].toolText);
		//Show the tool tip
		this.tTip.show();
		//Stop invoke clickURL 
		this.isClickMCPressed = false;
	}
	/**
	* barOnRollOut method is invoked when the mouse rolls out
	* of bar. We just hide the tool tip here.
	*/
	private function barOnRollOut():Void {
		//Hide the tool tip
		this.tTip.hide();
		//Stop invoke clickURL 
		this.isClickMCPressed = false;
	}
	/*
	* barOnMouseMove is called when the mouse position has changed
	* over bar. We reposition the tool tip.
	*/
	private function barOnMouseMove():Void {
		//Reposition the tool tip only if it's in visible state
		if (this.tTip.visible()) {
			this.tTip.rePosition();
		}
	}
	/**
	* barOnClick is invoked when the user clicks on a bar (if link
	* has been defined). We invoke the required link.
	*/
	private function barOnClick():Void {
		//Index of bar is stored in arguments.caller.index
		var dsindex:Number = arguments.caller.dsindex;
		var index:Number = arguments.caller.index;
		//Invoke the link
		super.invokeLink(this.dataset[dsindex].data[index].link);
	}
	/**
	 * legendClick method is the event handler for legend. In this method,
	 * we toggle the visibility of dataset.
	*/
	private function legendClick(target:Object):Void {
		if (this.chartDrawn) {
			//Update the container flag that the data-set is now visible/invisible
			objM.toggleGroupVisibility("DATAVALUES_"+target.index, target.active);
			objM.toggleGroupVisibility("DATAPLOTS_"+target.index, target.active);
			//Raise Legend Click external event
			this.raiseLegendItemClickedEvent({datasetIndex:target.index, datasetName:this.dataset [target.index].seriesName});
		} else {
			lgnd.cancelClickEvent(target.intIndex);
		}
	}
	/**
	* reInit method re-initializes the chart. This method is basically called
	* when the user changes chart data through JavaScript. In that case, we need
	* to re-initialize the chart, set new XML data and again render.
	*/
	public function reInit():Void {
		//Invoke super class's reInit
		super.reInit();
		//Now initialize things that are pertinent to this class
		//but not defined in super class.
		this.categories = new Array();
		this.dataset = new Array();
		//Initialize the number of data elements present
		this.numDS = 0;
		this.num = 0;
		//Destroy the legend
		this.lgnd.destroy ();
		if (this.params.interactiveLegend) {
			//Remove listener for legend object.
			this.lgnd.removeEventListener("legendClick", this);
		}
		//PlotSpacePercent initially considered as explicitly defined.
		this.defaultPlotSpacePercent = false;
	}
	/**
	* remove method removes the chart by clearing the chart movie clip
	* and removing any listeners.
	*/
	public function remove():Void {
		super.remove();
		//Remove class pertinent objects
		if (this.params.interactiveLegend) {
			//Remove listener for legend object.
			this.lgnd.removeEventListener("legendClick", this);
		}
		//Remove legend 
		this.lgnd.destroy();
		lgndMC.removeMovieClip();
	}
	//---------------DATA EXPORT HANDLERS-------------------//
	/**
	 * Returns the data of the chart in CSV/TSV format. The separator, qualifier and line
	 * break character is stored in params (during common parsing).
	 * @return	The data of the chart in CSV/TSV format, as specified in the XML.
	 */
	public function exportChartDataCSV():String {
		var strData:String = "";
		var strQ:String = this.params.exportDataQualifier;
		var strS:String = this.params.exportDataSeparator;
		var strLB:String = this.params.exportDataLineBreak;
		var i:Number, j:Number;
		strData = strQ + ((this.params.xAxisName!="")?(this.params.xAxisName):("Label")) + strQ + ((this.numDS > 0)? (strS): "");
		//Add all the series names
		for (i=1; i<=this.numDS; i++) {
			strData += strQ+((this.dataset[i].seriesName != "") ? (this.dataset[i].seriesName) : (""))+strQ+((i<this.numDS) ? (strS) : (strLB));
		}
		(this.numDS ==0)? strData +=strLB : strData;
		//Iterate through each data-items and add it to the output
		for (i=1; i<=this.num; i++) {
			//Add the category label
			strData += strQ + (this.categories [i].label)  + strQ + ((this.numDS > 0)? (strS): "");
			//Add the individual value for datasets
			for (j=1; j<=this.numDS; j++) {
				strData += strQ+((this.dataset[j].data[i].isDefined == true) ? ((this.params.exportDataFormattedVal == true) ? (this.dataset[j].data[i].formattedValue) : (this.dataset[j].data[i].value)) : (""))+strQ+((j<this.numDS) ? strS : "");
			}
			if (i<this.num) {
				strData += strLB;
			}
		}
		return strData;
	}
}
